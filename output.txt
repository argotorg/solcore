> AST after name resolution
import IndexLib ;
forall self args ret . class  self : invokable (args, ret) {
   forall self args . function invoke (self : self, args : args) -> ret;
}
function addW (x : word, y : word) {
   let res : word ;
   assembly {
      res := add(x, y)
   }
   return res;
}
function subW (x : word, y : word) {
   let res : word ;
   assembly {
      res := sub(x, y)
   }
   return res;
}
function addU (x : uint, y : uint) -> uint {
   let res : word ;
   let xw : word = Num.toWord(x) ;
   let yw : word = Num.toWord(y) ;
   assembly {
      res := add(xw, yw)
   }
   return uint(res);
}
function hash1 (x : word) -> word {
   let result : word = 0 ;
   assembly {
      mstore(0, x)
      result := keccak256(0, 32)
   }
   return result;
}
function hash2 (x : word, y : word) -> word {
   let result : word = 0 ;
   assembly {
      mstore(0, x)
      mstore(32, y)
      result := keccak256(0, 64)
   }
   return result;
}
data Bool = False  | True  ;
function not (b : Bool) -> Bool {
   match (b) {
   | False =>
      return True;
   | True =>
      return False;
   }
}
function or (x : Bool, y : Bool) -> Bool {
   match (x) {
   | False =>
      return y;
   | True =>
      return True;
   }
}
function fromBool (b) {
   match (b) {
   | False =>
      return 0;
   | True =>
      return 1;
   }
}
function toBool (x : word) {
   match (x) {
   | 0 =>
      return False;
   | _ =>
      return True;
   }
}
forall a . class  a : Eq {
   function eq (x : a, y : a) -> Bool;
}
instance word : Eq {
   function eq (x : word, y : word) -> Bool {
      let res : word ;
      assembly {
         res := eq(x, y)
      }
      return toBool(res);
   }
}
forall a .
a : Eq => function ne (x : a, y : a) {
   return not(Eq.eq(x, y));
}
forall a .
a : Eq => class  a : Num {
   function toWord (x : a) -> word;
   function fromWord (x : word) -> a;
   function add (x : a, y : a) -> a;
   function sub (x : a, y : a) -> a;
   function gt (x : a, y : a) -> Bool;
}
instance word : Num {
   function toWord (x : word) -> word {
      return x;
   }
   function fromWord (x : word) -> word {
      return x;
   }
   function add (x : word, y : word) -> word {
      return addW(x, y);
   }
   function sub (x : word, y : word) -> word {
      return addW(x, y);
   }
   function gt (x : word, y : word) -> Bool {
      let res : word ;
      assembly {
         res := gt(x, y)
      }
      return toBool(res);
   }
}
forall a .
a : Num => function ge (x : a, y : a) -> Bool {
   return or(Num.gt(x, y), Eq.eq(x, y));
}
data uint = uint(word) ;
instance uint : Eq {
   function eq (x : uint, y : uint) -> Bool {
      return Eq.eq(Num.toWord(x), Num.toWord(y));
   }
}
instance uint : Num {
   function toWord (x : uint) -> word {
      match (x) {
      | uint(y) =>
         return y;
      }
   }
   function fromWord (x : word) -> uint {
      return uint(x);
   }
   function add (x : uint, y : uint) -> uint {
      return uint(addW(Num.toWord(x), Num.toWord(y)));
   }
   function sub (x : uint, y : uint) -> uint {
      return uint(subW(Num.toWord(x), Num.toWord(y)));
   }
   function gt (x : uint, y : uint) -> Bool {
      return Num.gt(Num.toWord(x), Num.toWord(y));
   }
}
forall abs rep . class  abs : Typedef (rep) {
   function rep (x : abs) -> rep;
   function abs (x : rep) -> abs;
}
instance word : Typedef (word) {
   function rep (x : word) -> word {
      return x;
   }
   function abs (x : word) -> word {
      return x;
   }
}
instance uint : Typedef (word) {
   function rep (x : uint) -> word {
      match (x) {
      | uint(y) =>
         return y;
      }
   }
   function abs (x : word) -> uint {
      return uint(x);
   }
}
data address = address(word) ;
instance address : Typedef (word) {
   function rep (x : address) -> word {
      match (x) {
      | address(y) =>
         return y;
      }
   }
   function abs (x : word) -> address {
      return address(x);
   }
}
instance address : Eq {
   function eq (x : address, y : address) -> Bool {
      return Eq.eq(Typedef.rep(x), Typedef.rep(y));
   }
}
data storage (a) = storage(word) ;
data ContractStorage (cxt) = ContractStorage(cxt) ;
data storageRef (a) = storageRef(word) ;
data Proxy (a) = Proxy  ;
data mapping (member, index) = mapping(word, Proxy(member), Proxy(index)) ;
data mapRef (a) = mapRef(word) ;
forall a . instance storage(a) : Typedef (word) {
   function rep (x : storage(a)) -> word {
      match (x) {
      | storage(y) =>
         return y;
      }
   }
   function abs (x : word) -> storage(a) {
      return storage(x);
   }
}
forall a . instance storageRef(a) : Typedef (word) {
   function rep (x : storageRef(a)) -> word {
      match (x) {
      | storageRef(y) =>
         return y;
      }
   }
   function abs (x : word) -> storageRef(a) {
      return storageRef(x);
   }
}
forall lhs rhs . class  lhs : Assign (rhs) {
   function assign (l : lhs, r : rhs) -> ();
}
data ref (a) = ref(a) ;
forall a . instance ref(a) : Assign (a) {
   function assign (l : ref(a), r : a) -> () {
      return ();
   }
}
forall self . class  self : StorageType {
   function sload (ptr : word) -> self;
   function store (ptr : word, value : self) -> ();
}
forall self . class  self : StorageSize {
   function size (x : Proxy(self)) -> word;
}
function sload_ (x : word) -> word {
   let res : word ;
   assembly {
      res := sload(x)
   }
   return res;
}
function sstore_ (a : word, v : word) {
   assembly {
      sstore(a, v)
   }
}
instance word : StorageType {
   function sload (ptr : word) -> word {
      let r : word ;
      assembly {
         r := sload(ptr)
      }
      return r;
   }
   function store (ptr : word, value : word) -> () {
      assembly {
         sstore(ptr, value)
      }
   }
}
instance uint : StorageType {
   function sload (ptr : word) -> uint {
      return Typedef.abs(sload_(ptr));
   }
   function store (ptr : word, value : uint) -> () {
      return sstore_(ptr, Typedef.rep(value));
   }
}
instance address : StorageType {
   function sload (ptr : word) -> address {
      return Typedef.abs(sload_(ptr)) : address;
   }
   function store (ptr : word, value : address) -> () {
      return sstore_(ptr, Typedef.rep(value));
   }
}
forall a .
a : StorageType => instance storageRef(a) : Assign (a) {
   function assign (l : storageRef(a), y : a) -> () {
      StorageType.store(Typedef.rep(l), y);
   }
}
forall self fieldType offsetType . class  self : StructField (fieldType, offsetType) {
}
data StructField (structType, fieldSelector) = StructField(structType) ;
data MemberAccessProxy (a, field, offset) = MemberAccessProxy(a, field) ;
forall a field offset . function memberAccessD1 (x : MemberAccessProxy(a, field, offset)) -> a {
   match (x) {
   | MemberAccessProxy(y, z) =>
      return y;
   }
}
forall self memberRefType . class  self : LValueMemberAccess (memberRefType) {
   function memberAccess (x : self) -> memberRefType;
}
forall self memberValueType . class  self : RValueMemberAccess (memberValueType) {
   function memberAccess (x : self) -> memberValueType;
}
forall structType fieldSelector fieldType offsetType .
StructField(structType, fieldSelector) : StructField (fieldType, offsetType), offsetType : StorageSize => instance MemberAccessProxy(storage(structType), fieldSelector, offsetType) : LValueMemberAccess (storageRef(fieldType)) {
   function memberAccess (x : MemberAccessProxy(storage(structType), fieldSelector, offsetType)) -> storageRef(fieldType) {
      let ptr : word = Typedef.rep(memberAccessD1(x)) ;
      let size : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      assembly {
         ptr := add(ptr, size)
      }
      return storageRef(ptr);
   }
}
instance () : StorageSize {
   function size (x : Proxy(())) -> word {
      return 0;
   }
}
instance word : StorageSize {
   function size (x : Proxy(word)) -> word {
      return 1;
   }
}
instance uint : StorageSize {
   function size (x : Proxy(uint)) -> word {
      return 1;
   }
}
instance address : StorageSize {
   function size (x : Proxy(address)) -> word {
      return 1;
   }
}
forall a b .
a : StorageSize, b : StorageSize => instance (a, b) : StorageSize {
   function size (x : Proxy((a, b))) -> word {
      let a_sz : word = StorageSize.size(Proxy : Proxy(a)) ;
      let b_sz : word = StorageSize.size(Proxy : Proxy(b)) ;
      assembly {
         a_sz := add(a_sz, b_sz)
      }
      return a_sz;
   }
}
pragma no-patterson-condition RValueMemberAccess ;
pragma no-coverage-condition MemberAccessProxy, LValueMemberAccess, RValueMemberAccess ;
forall cxt fieldSelector fieldType offsetType .
StructField(ContractStorage(cxt), fieldSelector) : StructField (fieldType, offsetType), offsetType : StorageSize => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType) : LValueMemberAccess (storageRef(fieldType)) {
   function memberAccess (x : MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> storageRef(fieldType) {
      let ptr : word = 256 ;
      let offsetSize : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      assembly {
         ptr := add(ptr, offsetSize)
      }
      return storageRef(ptr);
   }
}
forall cxt fieldSelector fieldType offsetType .
StructField(ContractStorage(cxt), fieldSelector) : StructField (fieldType, offsetType), fieldType : StorageType, offsetType : StorageSize => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType) : RValueMemberAccess (fieldType) {
   function memberAccess (x : MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> fieldType {
      let ptr : word = 256 ;
      let offsetSize : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      return StorageType.sload(addW(ptr, offsetSize)) : fieldType;
   }
}
data mapping (index, member) = mapping(word) ;
forall member index . instance mapping(index, member) : Typedef (word) {
   function rep (x : mapping(index, member)) -> word {
      match (x) {
      | mapping(y) =>
         return y;
      }
   }
   function abs (x : word) -> mapping(index, member) {
      return mapping(x);
   }
}
forall index member . instance mapping(index, member) : StorageSize {
   function size (x : Proxy(mapping(index, member))) -> word {
      return 1;
   }
}
data IndexAccessProxy (map, index, member) = IndexAccessProxy(map, index) ;
forall index member .
index : Typedef (word) => instance IndexAccessProxy(storageRef(mapping(index, member)), index, member) : LValueMemberAccess (storageRef(member)) {
   function memberAccess (x : IndexAccessProxy(storageRef(mapping(index, member)), index, member)) -> storageRef(member) {
      return storageRef(indexStorageSlot(x));
   }
}
forall map index member .
index : Typedef (word), member : StorageType, map : Typedef (word) => instance IndexAccessProxy(map, index, member) : RValueMemberAccess (member) {
   function memberAccess (x : IndexAccessProxy(map, index, member)) -> member {
      let slot : word = indexStorageSlot(x) ;
      return StorageType.sload(slot);
   }
}
forall index map member .
map : Typedef (word), index : Typedef (word) => function indexStorageSlot (x : IndexAccessProxy(map, index, member)) -> word {
   match (x) {
   | IndexAccessProxy(map, i) =>
      let mapptr : word = Typedef.rep(map) ;
      let rawidx : word = Typedef.rep(i) ;
      let loc : word = hash2(mapptr, rawidx) ;
      return loc;
   }
}
forall a b .
a : RValueMemberAccess (b) => function rval (x : a) -> b {
   return RValueMemberAccess.memberAccess(x);
}
function caller () -> address {
   let res : word ;
   assembly {
      res := caller()
   }
   return address(res);
}
function require1fail () {
   let res : word ;
   assembly {
      mstore(0, 2320231852978620534530211544385868)
      revert(0, 32)
   }
   return ();
}
function require1 (cond : Bool) {
   match (cond) {
   | False =>
      return require1fail();
   | True =>
      return ();
   }
}
function nop () -> () {
   return ();
}
data UintCxt = UintCxt  ;
data reserved_sel = reserved_sel  ;
instance StructField(ContractStorage(UintCxt), reserved_sel) : StructField (word, ()) {
}
data msg_sender_sel = msg_sender_sel  ;
instance StructField(ContractStorage(UintCxt), msg_sender_sel) : StructField (address, (word, ())) {
}
data owner_sel = owner_sel  ;
instance StructField(ContractStorage(UintCxt), owner_sel) : StructField (address, (word, (address, ()))) {
}
data decimals_sel = decimals_sel  ;
instance StructField(ContractStorage(UintCxt), decimals_sel) : StructField (uint, (word, (address, (address, ())))) {
}
data totalSupply_sel = totalSupply_sel  ;
instance StructField(ContractStorage(UintCxt), totalSupply_sel) : StructField (uint, (word, (address, (address, (uint, ()))))) {
}
data balances_sel = balances_sel  ;
instance StructField(ContractStorage(UintCxt), balances_sel) : StructField (mapping(address, uint), (word, (address, (address, (uint, (uint, ())))))) {
}
contract Uint {
   function withdraw (src : address, amt : uint) {
      Assign.assign(LValueMemberAccess.memberAccess(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), Num.sub(rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), amt) : uint);
   }
   function main () {
      withdraw(rval(MemberAccessProxy(ContractStorage(UintCxt), msg_sender_sel)), rval(MemberAccessProxy(ContractStorage(UintCxt), totalSupply_sel)));
      return rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), rval(MemberAccessProxy(ContractStorage(UintCxt), msg_sender_sel)))) : uint;
   }
}
> SCC Analysis:
import IndexLib ;
pragma no-patterson-condition RValueMemberAccess ;
pragma no-coverage-condition MemberAccessProxy, LValueMemberAccess, RValueMemberAccess ;
data uint = uint(word) ;
data totalSupply_sel = totalSupply_sel  ;
data storageRef (a) = storageRef(word) ;
data storage (a) = storage(word) ;
data reserved_sel = reserved_sel  ;
data ref (a) = ref(a) ;
data owner_sel = owner_sel  ;
data msg_sender_sel = msg_sender_sel  ;
data Proxy (a) = Proxy  ;
data mapping (member, index) = mapping(word, Proxy(member), Proxy(index)) ;
data mapping (index, member) = mapping(word) ;
data mapRef (a) = mapRef(word) ;
data decimals_sel = decimals_sel  ;
data balances_sel = balances_sel  ;
data address = address(word) ;
data UintCxt = UintCxt  ;
data StructField (structType, fieldSelector) = StructField(structType) ;
data MemberAccessProxy (a, field, offset) = MemberAccessProxy(a, field) ;
data IndexAccessProxy (map, index, member) = IndexAccessProxy(map, index) ;
data ContractStorage (cxt) = ContractStorage(cxt) ;
data Bool = False  | True  ;
forall a field offset . function memberAccessD1 (x : MemberAccessProxy(a, field, offset)) -> a {
   match (x) {
   | MemberAccessProxy(y, z) =>
      return y;
   }
}
forall structType fieldSelector fieldType offsetType .
StructField(structType, fieldSelector) : StructField (fieldType, offsetType), offsetType : StorageSize => instance MemberAccessProxy(storage(structType), fieldSelector, offsetType) : LValueMemberAccess (storageRef(fieldType)) {
   function memberAccess (x : MemberAccessProxy(storage(structType), fieldSelector, offsetType)) -> storageRef(fieldType) {
      let ptr : word = Typedef.rep(memberAccessD1(x)) ;
      let size : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      assembly {
         ptr := add(ptr, size)
      }
      return storageRef(ptr);
   }
}
forall member index . instance mapping(index, member) : Typedef (word) {
   function rep (x : mapping(index, member)) -> word {
      match (x) {
      | mapping(y) =>
         return y;
      }
   }
   function abs (x : word) -> mapping(index, member) {
      return mapping(x);
   }
}
function hash2 (x : word, y : word) -> word {
   let result : word = 0 ;
   assembly {
      mstore(0, x)
      mstore(32, y)
      result := keccak256(0, 64)
   }
   return result;
}
forall index map member .
map : Typedef (word), index : Typedef (word) => function indexStorageSlot (x : IndexAccessProxy(map, index, member)) -> word {
   match (x) {
   | IndexAccessProxy(map, i) =>
      let mapptr : word = Typedef.rep(map) ;
      let rawidx : word = Typedef.rep(i) ;
      let loc : word = hash2(mapptr, rawidx) ;
      return loc;
   }
}
forall map index member .
index : Typedef (word), member : StorageType, map : Typedef (word) => instance IndexAccessProxy(map, index, member) : RValueMemberAccess (member) {
   function memberAccess (x : IndexAccessProxy(map, index, member)) -> member {
      let slot : word = indexStorageSlot(x) ;
      return StorageType.sload(slot);
   }
}
forall index member .
index : Typedef (word) => instance IndexAccessProxy(storageRef(mapping(index, member)), index, member) : LValueMemberAccess (storageRef(member)) {
   function memberAccess (x : IndexAccessProxy(storageRef(mapping(index, member)), index, member)) -> storageRef(member) {
      return storageRef(indexStorageSlot(x));
   }
}
forall index member . instance mapping(index, member) : StorageSize {
   function size (x : Proxy(mapping(index, member))) -> word {
      return 1;
   }
}
function addW (x : word, y : word) {
   let res : word ;
   assembly {
      res := add(x, y)
   }
   return res;
}
forall cxt fieldSelector fieldType offsetType .
StructField(ContractStorage(cxt), fieldSelector) : StructField (fieldType, offsetType), fieldType : StorageType, offsetType : StorageSize => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType) : RValueMemberAccess (fieldType) {
   function memberAccess (x : MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> fieldType {
      let ptr : word = 256 ;
      let offsetSize : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      return StorageType.sload(addW(ptr, offsetSize)) : fieldType;
   }
}
forall cxt fieldSelector fieldType offsetType .
StructField(ContractStorage(cxt), fieldSelector) : StructField (fieldType, offsetType), offsetType : StorageSize => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType) : LValueMemberAccess (storageRef(fieldType)) {
   function memberAccess (x : MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> storageRef(fieldType) {
      let ptr : word = 256 ;
      let offsetSize : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      assembly {
         ptr := add(ptr, offsetSize)
      }
      return storageRef(ptr);
   }
}
forall a b .
a : StorageSize, b : StorageSize => instance (a, b) : StorageSize {
   function size (x : Proxy((a, b))) -> word {
      let a_sz : word = StorageSize.size(Proxy : Proxy(a)) ;
      let b_sz : word = StorageSize.size(Proxy : Proxy(b)) ;
      assembly {
         a_sz := add(a_sz, b_sz)
      }
      return a_sz;
   }
}
forall a .
a : StorageType => instance storageRef(a) : Assign (a) {
   function assign (l : storageRef(a), y : a) -> () {
      StorageType.store(Typedef.rep(l), y);
   }
}
forall a . instance storageRef(a) : Typedef (word) {
   function rep (x : storageRef(a)) -> word {
      match (x) {
      | storageRef(y) =>
         return y;
      }
   }
   function abs (x : word) -> storageRef(a) {
      return storageRef(x);
   }
}
forall a . instance storage(a) : Typedef (word) {
   function rep (x : storage(a)) -> word {
      match (x) {
      | storage(y) =>
         return y;
      }
   }
   function abs (x : word) -> storage(a) {
      return storage(x);
   }
}
forall a . instance ref(a) : Assign (a) {
   function assign (l : ref(a), r : a) -> () {
      return ();
   }
}
instance word : Typedef (word) {
   function rep (x : word) -> word {
      return x;
   }
   function abs (x : word) -> word {
      return x;
   }
}
instance uint : Typedef (word) {
   function rep (x : uint) -> word {
      match (x) {
      | uint(y) =>
         return y;
      }
   }
   function abs (x : word) -> uint {
      return uint(x);
   }
}
instance address : Typedef (word) {
   function rep (x : address) -> word {
      match (x) {
      | address(y) =>
         return y;
      }
   }
   function abs (x : word) -> address {
      return address(x);
   }
}
instance StructField(ContractStorage(UintCxt), reserved_sel) : StructField (word, ()) {
}
instance StructField(ContractStorage(UintCxt), totalSupply_sel) : StructField (uint, (word, (address, (address, (uint, ()))))) {
}
instance StructField(ContractStorage(UintCxt), decimals_sel) : StructField (uint, (word, (address, (address, ())))) {
}
instance StructField(ContractStorage(UintCxt), balances_sel) : StructField (mapping(address, uint), (word, (address, (address, (uint, (uint, ())))))) {
}
instance StructField(ContractStorage(UintCxt), owner_sel) : StructField (address, (word, (address, ()))) {
}
instance StructField(ContractStorage(UintCxt), msg_sender_sel) : StructField (address, (word, ())) {
}
instance word : StorageType {
   function sload (ptr : word) -> word {
      let r : word ;
      assembly {
         r := sload(ptr)
      }
      return r;
   }
   function store (ptr : word, value : word) -> () {
      assembly {
         sstore(ptr, value)
      }
   }
}
function sstore_ (a : word, v : word) {
   assembly {
      sstore(a, v)
   }
}
function sload_ (x : word) -> word {
   let res : word ;
   assembly {
      res := sload(x)
   }
   return res;
}
instance uint : StorageType {
   function sload (ptr : word) -> uint {
      return Typedef.abs(sload_(ptr));
   }
   function store (ptr : word, value : uint) -> () {
      return sstore_(ptr, Typedef.rep(value));
   }
}
instance address : StorageType {
   function sload (ptr : word) -> address {
      return Typedef.abs(sload_(ptr)) : address;
   }
   function store (ptr : word, value : address) -> () {
      return sstore_(ptr, Typedef.rep(value));
   }
}
instance word : StorageSize {
   function size (x : Proxy(word)) -> word {
      return 1;
   }
}
instance uint : StorageSize {
   function size (x : Proxy(uint)) -> word {
      return 1;
   }
}
instance address : StorageSize {
   function size (x : Proxy(address)) -> word {
      return 1;
   }
}
instance () : StorageSize {
   function size (x : Proxy(())) -> word {
      return 0;
   }
}
function toBool (x : word) {
   match (x) {
   | 0 =>
      return False;
   | _ =>
      return True;
   }
}
instance word : Num {
   function toWord (x : word) -> word {
      return x;
   }
   function fromWord (x : word) -> word {
      return x;
   }
   function add (x : word, y : word) -> word {
      return addW(x, y);
   }
   function sub (x : word, y : word) -> word {
      return addW(x, y);
   }
   function gt (x : word, y : word) -> Bool {
      let res : word ;
      assembly {
         res := gt(x, y)
      }
      return toBool(res);
   }
}
function subW (x : word, y : word) {
   let res : word ;
   assembly {
      res := sub(x, y)
   }
   return res;
}
instance uint : Num {
   function toWord (x : uint) -> word {
      match (x) {
      | uint(y) =>
         return y;
      }
   }
   function fromWord (x : word) -> uint {
      return uint(x);
   }
   function add (x : uint, y : uint) -> uint {
      return uint(addW(Num.toWord(x), Num.toWord(y)));
   }
   function sub (x : uint, y : uint) -> uint {
      return uint(subW(Num.toWord(x), Num.toWord(y)));
   }
   function gt (x : uint, y : uint) -> Bool {
      return Num.gt(Num.toWord(x), Num.toWord(y));
   }
}
instance word : Eq {
   function eq (x : word, y : word) -> Bool {
      let res : word ;
      assembly {
         res := eq(x, y)
      }
      return toBool(res);
   }
}
instance uint : Eq {
   function eq (x : uint, y : uint) -> Bool {
      return Eq.eq(Num.toWord(x), Num.toWord(y));
   }
}
instance address : Eq {
   function eq (x : address, y : address) -> Bool {
      return Eq.eq(Typedef.rep(x), Typedef.rep(y));
   }
}
forall self memberValueType . class  self : RValueMemberAccess (memberValueType) {
   function memberAccess (x : self) -> memberValueType;
}
forall self memberRefType . class  self : LValueMemberAccess (memberRefType) {
   function memberAccess (x : self) -> memberRefType;
}
forall self fieldType offsetType . class  self : StructField (fieldType, offsetType) {
}
forall self args ret . class  self : invokable (args, ret) {
   forall self args . function invoke (self : self, args : args) -> ret;
}
forall self . class  self : StorageType {
   function sload (ptr : word) -> self;
   function store (ptr : word, value : self) -> ();
}
forall self . class  self : StorageSize {
   function size (x : Proxy(self)) -> word;
}
forall lhs rhs . class  lhs : Assign (rhs) {
   function assign (l : lhs, r : rhs) -> ();
}
forall abs rep . class  abs : Typedef (rep) {
   function rep (x : abs) -> rep;
   function abs (x : rep) -> abs;
}
forall a .
a : Eq => class  a : Num {
   function toWord (x : a) -> word;
   function fromWord (x : word) -> a;
   function add (x : a, y : a) -> a;
   function sub (x : a, y : a) -> a;
   function gt (x : a, y : a) -> Bool;
}
forall a . class  a : Eq {
   function eq (x : a, y : a) -> Bool;
}
forall a b .
a : RValueMemberAccess (b) => function rval (x : a) -> b {
   return RValueMemberAccess.memberAccess(x);
}
function or (x : Bool, y : Bool) -> Bool {
   match (x) {
   | False =>
      return y;
   | True =>
      return True;
   }
}
forall a .
a : Num => function ge (x : a, y : a) -> Bool {
   return or(Num.gt(x, y), Eq.eq(x, y));
}
function not (b : Bool) -> Bool {
   match (b) {
   | False =>
      return True;
   | True =>
      return False;
   }
}
forall a .
a : Eq => function ne (x : a, y : a) {
   return not(Eq.eq(x, y));
}
function require1fail () {
   let res : word ;
   assembly {
      mstore(0, 2320231852978620534530211544385868)
      revert(0, 32)
   }
   return ();
}
function require1 (cond : Bool) {
   match (cond) {
   | False =>
      return require1fail();
   | True =>
      return ();
   }
}
function nop () -> () {
   return ();
}
function hash1 (x : word) -> word {
   let result : word = 0 ;
   assembly {
      mstore(0, x)
      result := keccak256(0, 32)
   }
   return result;
}
function fromBool (b) {
   match (b) {
   | False =>
      return 0;
   | True =>
      return 1;
   }
}
function caller () -> address {
   let res : word ;
   assembly {
      res := caller()
   }
   return address(res);
}
function addU (x : uint, y : uint) -> uint {
   let res : word ;
   let xw : word = Num.toWord(x) ;
   let yw : word = Num.toWord(y) ;
   assembly {
      res := add(xw, yw)
   }
   return uint(res);
}
contract Uint {
   function withdraw (src : address, amt : uint) {
      Assign.assign(LValueMemberAccess.memberAccess(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), Num.sub(rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), amt) : uint);
   }
   function main () {
      withdraw(rval(MemberAccessProxy(ContractStorage(UintCxt), msg_sender_sel)), rval(MemberAccessProxy(ContractStorage(UintCxt), totalSupply_sel)));
      return rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), rval(MemberAccessProxy(ContractStorage(UintCxt), msg_sender_sel)))) : uint;
   }
}
> Indirect call desugaring:
import IndexLib ;
pragma no-patterson-condition RValueMemberAccess ;
pragma no-coverage-condition MemberAccessProxy, LValueMemberAccess, RValueMemberAccess ;
data uint = uint(word) ;
data totalSupply_sel = totalSupply_sel  ;
data storageRef (a) = storageRef(word) ;
data storage (a) = storage(word) ;
data reserved_sel = reserved_sel  ;
data ref (a) = ref(a) ;
data owner_sel = owner_sel  ;
data msg_sender_sel = msg_sender_sel  ;
data Proxy (a) = Proxy  ;
data mapping (member, index) = mapping(word, Proxy(member), Proxy(index)) ;
data mapping (index, member) = mapping(word) ;
data mapRef (a) = mapRef(word) ;
data decimals_sel = decimals_sel  ;
data balances_sel = balances_sel  ;
data address = address(word) ;
data UintCxt = UintCxt  ;
data StructField (structType, fieldSelector) = StructField(structType) ;
data MemberAccessProxy (a, field, offset) = MemberAccessProxy(a, field) ;
data IndexAccessProxy (map, index, member) = IndexAccessProxy(map, index) ;
data ContractStorage (cxt) = ContractStorage(cxt) ;
data Bool = False  | True  ;
forall a field offset . function memberAccessD1 (x : MemberAccessProxy(a, field, offset)) -> a {
   match (x) {
   | MemberAccessProxy(y, z) =>
      return y;
   }
}
forall structType fieldSelector fieldType offsetType .
StructField(structType, fieldSelector) : StructField (fieldType, offsetType), offsetType : StorageSize => instance MemberAccessProxy(storage(structType), fieldSelector, offsetType) : LValueMemberAccess (storageRef(fieldType)) {
   function memberAccess (x : MemberAccessProxy(storage(structType), fieldSelector, offsetType)) -> storageRef(fieldType) {
      let ptr : word = Typedef.rep(memberAccessD1(x)) ;
      let size : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      assembly {
         ptr := add(ptr, size)
      }
      return storageRef(ptr);
   }
}
forall member index . instance mapping(index, member) : Typedef (word) {
   function rep (x : mapping(index, member)) -> word {
      match (x) {
      | mapping(y) =>
         return y;
      }
   }
   function abs (x : word) -> mapping(index, member) {
      return mapping(x);
   }
}
function hash2 (x : word, y : word) -> word {
   let result : word = 0 ;
   assembly {
      mstore(0, x)
      mstore(32, y)
      result := keccak256(0, 64)
   }
   return result;
}
forall index map member .
map : Typedef (word), index : Typedef (word) => function indexStorageSlot (x : IndexAccessProxy(map, index, member)) -> word {
   match (x) {
   | IndexAccessProxy(map, i) =>
      let mapptr : word = Typedef.rep(map) ;
      let rawidx : word = Typedef.rep(i) ;
      let loc : word = hash2(mapptr, rawidx) ;
      return loc;
   }
}
forall map index member .
index : Typedef (word), member : StorageType, map : Typedef (word) => instance IndexAccessProxy(map, index, member) : RValueMemberAccess (member) {
   function memberAccess (x : IndexAccessProxy(map, index, member)) -> member {
      let slot : word = indexStorageSlot(x) ;
      return StorageType.sload(slot);
   }
}
forall index member .
index : Typedef (word) => instance IndexAccessProxy(storageRef(mapping(index, member)), index, member) : LValueMemberAccess (storageRef(member)) {
   function memberAccess (x : IndexAccessProxy(storageRef(mapping(index, member)), index, member)) -> storageRef(member) {
      return storageRef(indexStorageSlot(x));
   }
}
forall index member . instance mapping(index, member) : StorageSize {
   function size (x : Proxy(mapping(index, member))) -> word {
      return 1;
   }
}
function addW (x : word, y : word) {
   let res : word ;
   assembly {
      res := add(x, y)
   }
   return res;
}
forall cxt fieldSelector fieldType offsetType .
StructField(ContractStorage(cxt), fieldSelector) : StructField (fieldType, offsetType), fieldType : StorageType, offsetType : StorageSize => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType) : RValueMemberAccess (fieldType) {
   function memberAccess (x : MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> fieldType {
      let ptr : word = 256 ;
      let offsetSize : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      return StorageType.sload(addW(ptr, offsetSize)) : fieldType;
   }
}
forall cxt fieldSelector fieldType offsetType .
StructField(ContractStorage(cxt), fieldSelector) : StructField (fieldType, offsetType), offsetType : StorageSize => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType) : LValueMemberAccess (storageRef(fieldType)) {
   function memberAccess (x : MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> storageRef(fieldType) {
      let ptr : word = 256 ;
      let offsetSize : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      assembly {
         ptr := add(ptr, offsetSize)
      }
      return storageRef(ptr);
   }
}
forall a b .
a : StorageSize, b : StorageSize => instance (a, b) : StorageSize {
   function size (x : Proxy((a, b))) -> word {
      let a_sz : word = StorageSize.size(Proxy : Proxy(a)) ;
      let b_sz : word = StorageSize.size(Proxy : Proxy(b)) ;
      assembly {
         a_sz := add(a_sz, b_sz)
      }
      return a_sz;
   }
}
forall a .
a : StorageType => instance storageRef(a) : Assign (a) {
   function assign (l : storageRef(a), y : a) -> () {
      StorageType.store(Typedef.rep(l), y);
   }
}
forall a . instance storageRef(a) : Typedef (word) {
   function rep (x : storageRef(a)) -> word {
      match (x) {
      | storageRef(y) =>
         return y;
      }
   }
   function abs (x : word) -> storageRef(a) {
      return storageRef(x);
   }
}
forall a . instance storage(a) : Typedef (word) {
   function rep (x : storage(a)) -> word {
      match (x) {
      | storage(y) =>
         return y;
      }
   }
   function abs (x : word) -> storage(a) {
      return storage(x);
   }
}
forall a . instance ref(a) : Assign (a) {
   function assign (l : ref(a), r : a) -> () {
      return ();
   }
}
instance word : Typedef (word) {
   function rep (x : word) -> word {
      return x;
   }
   function abs (x : word) -> word {
      return x;
   }
}
instance uint : Typedef (word) {
   function rep (x : uint) -> word {
      match (x) {
      | uint(y) =>
         return y;
      }
   }
   function abs (x : word) -> uint {
      return uint(x);
   }
}
instance address : Typedef (word) {
   function rep (x : address) -> word {
      match (x) {
      | address(y) =>
         return y;
      }
   }
   function abs (x : word) -> address {
      return address(x);
   }
}
instance StructField(ContractStorage(UintCxt), reserved_sel) : StructField (word, ()) {
}
instance StructField(ContractStorage(UintCxt), totalSupply_sel) : StructField (uint, (word, (address, (address, (uint, ()))))) {
}
instance StructField(ContractStorage(UintCxt), decimals_sel) : StructField (uint, (word, (address, (address, ())))) {
}
instance StructField(ContractStorage(UintCxt), balances_sel) : StructField (mapping(address, uint), (word, (address, (address, (uint, (uint, ())))))) {
}
instance StructField(ContractStorage(UintCxt), owner_sel) : StructField (address, (word, (address, ()))) {
}
instance StructField(ContractStorage(UintCxt), msg_sender_sel) : StructField (address, (word, ())) {
}
instance word : StorageType {
   function sload (ptr : word) -> word {
      let r : word ;
      assembly {
         r := sload(ptr)
      }
      return r;
   }
   function store (ptr : word, value : word) -> () {
      assembly {
         sstore(ptr, value)
      }
   }
}
function sstore_ (a : word, v : word) {
   assembly {
      sstore(a, v)
   }
}
function sload_ (x : word) -> word {
   let res : word ;
   assembly {
      res := sload(x)
   }
   return res;
}
instance uint : StorageType {
   function sload (ptr : word) -> uint {
      return Typedef.abs(sload_(ptr));
   }
   function store (ptr : word, value : uint) -> () {
      return sstore_(ptr, Typedef.rep(value));
   }
}
instance address : StorageType {
   function sload (ptr : word) -> address {
      return Typedef.abs(sload_(ptr)) : address;
   }
   function store (ptr : word, value : address) -> () {
      return sstore_(ptr, Typedef.rep(value));
   }
}
instance word : StorageSize {
   function size (x : Proxy(word)) -> word {
      return 1;
   }
}
instance uint : StorageSize {
   function size (x : Proxy(uint)) -> word {
      return 1;
   }
}
instance address : StorageSize {
   function size (x : Proxy(address)) -> word {
      return 1;
   }
}
instance () : StorageSize {
   function size (x : Proxy(())) -> word {
      return 0;
   }
}
function toBool (x : word) {
   match (x) {
   | 0 =>
      return False;
   | _ =>
      return True;
   }
}
instance word : Num {
   function toWord (x : word) -> word {
      return x;
   }
   function fromWord (x : word) -> word {
      return x;
   }
   function add (x : word, y : word) -> word {
      return addW(x, y);
   }
   function sub (x : word, y : word) -> word {
      return addW(x, y);
   }
   function gt (x : word, y : word) -> Bool {
      let res : word ;
      assembly {
         res := gt(x, y)
      }
      return toBool(res);
   }
}
function subW (x : word, y : word) {
   let res : word ;
   assembly {
      res := sub(x, y)
   }
   return res;
}
instance uint : Num {
   function toWord (x : uint) -> word {
      match (x) {
      | uint(y) =>
         return y;
      }
   }
   function fromWord (x : word) -> uint {
      return uint(x);
   }
   function add (x : uint, y : uint) -> uint {
      return uint(addW(Num.toWord(x), Num.toWord(y)));
   }
   function sub (x : uint, y : uint) -> uint {
      return uint(subW(Num.toWord(x), Num.toWord(y)));
   }
   function gt (x : uint, y : uint) -> Bool {
      return Num.gt(Num.toWord(x), Num.toWord(y));
   }
}
instance word : Eq {
   function eq (x : word, y : word) -> Bool {
      let res : word ;
      assembly {
         res := eq(x, y)
      }
      return toBool(res);
   }
}
instance uint : Eq {
   function eq (x : uint, y : uint) -> Bool {
      return Eq.eq(Num.toWord(x), Num.toWord(y));
   }
}
instance address : Eq {
   function eq (x : address, y : address) -> Bool {
      return Eq.eq(Typedef.rep(x), Typedef.rep(y));
   }
}
forall self memberValueType . class  self : RValueMemberAccess (memberValueType) {
   function memberAccess (x : self) -> memberValueType;
}
forall self memberRefType . class  self : LValueMemberAccess (memberRefType) {
   function memberAccess (x : self) -> memberRefType;
}
forall self fieldType offsetType . class  self : StructField (fieldType, offsetType) {
}
forall self args ret . class  self : invokable (args, ret) {
   forall self args . function invoke (self : self, args : args) -> ret;
}
forall self . class  self : StorageType {
   function sload (ptr : word) -> self;
   function store (ptr : word, value : self) -> ();
}
forall self . class  self : StorageSize {
   function size (x : Proxy(self)) -> word;
}
forall lhs rhs . class  lhs : Assign (rhs) {
   function assign (l : lhs, r : rhs) -> ();
}
forall abs rep . class  abs : Typedef (rep) {
   function rep (x : abs) -> rep;
   function abs (x : rep) -> abs;
}
forall a .
a : Eq => class  a : Num {
   function toWord (x : a) -> word;
   function fromWord (x : word) -> a;
   function add (x : a, y : a) -> a;
   function sub (x : a, y : a) -> a;
   function gt (x : a, y : a) -> Bool;
}
forall a . class  a : Eq {
   function eq (x : a, y : a) -> Bool;
}
forall a b .
a : RValueMemberAccess (b) => function rval (x : a) -> b {
   return RValueMemberAccess.memberAccess(x);
}
function or (x : Bool, y : Bool) -> Bool {
   match (x) {
   | False =>
      return y;
   | True =>
      return True;
   }
}
forall a .
a : Num => function ge (x : a, y : a) -> Bool {
   return or(Num.gt(x, y), Eq.eq(x, y));
}
function not (b : Bool) -> Bool {
   match (b) {
   | False =>
      return True;
   | True =>
      return False;
   }
}
forall a .
a : Eq => function ne (x : a, y : a) {
   return not(Eq.eq(x, y));
}
function require1fail () {
   let res : word ;
   assembly {
      mstore(0, 2320231852978620534530211544385868)
      revert(0, 32)
   }
   return ();
}
function require1 (cond : Bool) {
   match (cond) {
   | False =>
      return require1fail();
   | True =>
      return ();
   }
}
function nop () -> () {
   return ();
}
function hash1 (x : word) -> word {
   let result : word = 0 ;
   assembly {
      mstore(0, x)
      result := keccak256(0, 32)
   }
   return result;
}
function fromBool (b) {
   match (b) {
   | False =>
      return 0;
   | True =>
      return 1;
   }
}
function caller () -> address {
   let res : word ;
   assembly {
      res := caller()
   }
   return address(res);
}
function addU (x : uint, y : uint) -> uint {
   let res : word ;
   let xw : word = Num.toWord(x) ;
   let yw : word = Num.toWord(y) ;
   assembly {
      res := add(xw, yw)
   }
   return uint(res);
}
contract Uint {
   function withdraw (src : address, amt : uint) {
      Assign.assign(LValueMemberAccess.memberAccess(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), Num.sub(rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), amt) : uint);
   }
   function main () {
      withdraw(rval(MemberAccessProxy(ContractStorage(UintCxt), msg_sender_sel)), rval(MemberAccessProxy(ContractStorage(UintCxt), totalSupply_sel)));
      return rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), rval(MemberAccessProxy(ContractStorage(UintCxt), msg_sender_sel)))) : uint;
   }
}

Logs:

# tcFunDef forall a field offset . function memberAccessD1 (x : MemberAccessProxy(a, field, offset)) -> a
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: forall j50 g50 h50 . MemberAccessProxy(j50, g50, h50) -> j50
>> Checking subsumption for:
forall j50 g50 h50 . MemberAccessProxy(j50, g50, h50) -> j50
and
forall a field offset . MemberAccessProxy(a, field, offset) -> a
!> Creating unique type for memberAccessD1 :: forall a field offset . MemberAccessProxy(a, field, offset) -> a
!>>> Result:data t_memberAccessD10 (a, field, offset) = t_memberAccessD10  ;
>> Starting the creation of instance for memberAccessD1 :: forall a field offset . MemberAccessProxy(a, field, offset) -> a
>> Generated invokable instance:
forall a field offset . instance t_memberAccessD10(a, field, offset) : invokable (MemberAccessProxy(a, field, offset), a) {
   function invoke (self1 : t_memberAccessD10(a, field, offset), arg2 : MemberAccessProxy(a, field, offset)) -> a {
      match ((self1, arg2)) {
      | (t_memberAccessD10, MemberAccessProxy(x58, y58)) =>
         return memberAccessD1(MemberAccessProxy(x58, y58));
      }
   }
}

# tcFunDef function invoke (self1 : t_memberAccessD10(?c61, ?d61, ?e61), arg2 : MemberAccessProxy(?c61, ?d61, ?e61)) -> ?c61
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: forall m61 e62 e61 . t_memberAccessD10(m61, e62, e61) -> MemberAccessProxy(m61, e62, e61) -> m61
>> Checking subsumption for:
forall m61 e62 e61 . t_memberAccessD10(m61, e62, e61) -> MemberAccessProxy(m61, e62, e61) -> m61
and
t_memberAccessD10(?c61, ?d61, ?e61) -> MemberAccessProxy(?c61, ?d61, ?e61) -> ?c61

# tcFunDef function memberAccess (x : MemberAccessProxy(storage(?k71), ?l71, ?n71)) -> storageRef(?m71)
## predicates in signature:(StructField(?k71, ?l71) : StructField (?m71, ?n71), ?n71 : StorageSize)
> Reducing wanted constraints:(storage(?k71) : Typedef (word), ?n71 : StorageSize) using (StructField(?k71, ?l71) : StructField (?d72, ?n71), ?n71 : StorageSize)
> After entailment:(storage(?k71) : Typedef (word)) - (StructField(?k71, ?l71) : StructField (?d72, ?n71), ?n71 : StorageSize)
>> Before eliminating equalities (storage(?k71) : Typedef (word))
>> After eliminating equalities:(storage(?k71) : Typedef (word))
>>> Found instance for:storage(?k71) : Typedef (word)
>>>Instance:?v76 ~ word => storage(?w76) : Typedef (?v76)
>>>Subst:{?w76 +-> ?k71, ?v76 +-> word}
>> Before eliminating equalities (word ~ word)
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (StructField(?k71, ?l71) : StructField (?d72, ?n71), ?n71 : StorageSize)
<!! Final simplified constraints:(StructField(?k71, ?l71) : StructField (?d72, ?n71), ?n71 : StorageSize)
>>! Trying to check the entailment of:(StructField(?k71, ?l71) : StructField (?d72, ?n71), ?n71 : StorageSize) from:(StructField(?k71, ?l71) : StructField (?d72, ?n71), ?n71 : StorageSize)
>>! Simplified given constraints:(StructField(?k71, ?l71) : StructField (?d72, ?n71), ?n71 : StorageSize)
<<!! Unsolved:()
 - Reduced context: [StructField(?k71, ?l71) : StructField (?d72, ?n71), ?n71 : StorageSize]
 - generalized inferred type: forall k71 l71 d72 n71 . StructField(k71, l71) : StructField (d72, n71), n71 : StorageSize => MemberAccessProxy(storage(k71), l71, n71) -> storageRef(d72)
>> Checking subsumption for:
forall k71 l71 d72 n71 . StructField(k71, l71) : StructField (d72, n71), n71 : StorageSize => MemberAccessProxy(storage(k71), l71, n71) -> storageRef(d72)
and
MemberAccessProxy(storage(?k71), ?l71, ?n71) -> storageRef(?m71)

# tcFunDef function rep (x : mapping(?o83, ?n83)) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: forall o83 n83 . mapping(o83, n83) -> word
>> Checking subsumption for:
forall o83 n83 . mapping(o83, n83) -> word
and
mapping(?o83, ?n83) -> word

# tcFunDef function abs (x : word) -> mapping(?o83, ?n83)
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: forall q92 r92 . word -> mapping(q92, r92)
>> Checking subsumption for:
forall q92 r92 . word -> mapping(q92, r92)
and
word -> mapping(?o83, ?n83)

# tcFunDef function hash2 (x : word, y : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word -> word
>> Checking subsumption for:
word -> word -> word
and
word -> word -> word
!> Creating unique type for hash2 :: word -> word -> word
!>>> Result:data t_hash23 = t_hash23  ;
>> Starting the creation of instance for hash2 :: word -> word -> word
>> Generated invokable instance:
instance t_hash23 : invokable ((word, word), word) {
   function invoke (self4 : t_hash23, arg5 : (word, word)) -> word {
      match ((self4, arg5)) {
      | (t_hash23, (r110, s110)) =>
         return hash2(r110, s110);
      }
   }
}

# tcFunDef function invoke (self4 : t_hash23, arg5 : (word, word)) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_hash23 -> (word, word) -> word
>> Checking subsumption for:
t_hash23 -> (word, word) -> word
and
t_hash23 -> (word, word) -> word

# tcFunDef forall index map member .
map : Typedef (word), index : Typedef (word) => function indexStorageSlot (x : IndexAccessProxy(map, index, member)) -> word
## predicates in signature:(?w122 : Typedef (word), ?v122 : Typedef (word))
> Reducing wanted constraints:(?w122 : Typedef (word), ?v122 : Typedef (word)) using (?w122 : Typedef (word), ?v122 : Typedef (word))
> After entailment:() - (?w122 : Typedef (word), ?v122 : Typedef (word))
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?w122 : Typedef (word), ?v122 : Typedef (word))
<!! Final simplified constraints:(?w122 : Typedef (word), ?v122 : Typedef (word))
>>! Trying to check the entailment of:(?w122 : Typedef (word), ?v122 : Typedef (word)) from:(?w122 : Typedef (word), ?v122 : Typedef (word))
>>! Simplified given constraints:(?w122 : Typedef (word), ?v122 : Typedef (word))
<<!! Unsolved:()
 - Reduced context: [?w122 : Typedef (word), ?v122 : Typedef (word)]
 - generalized inferred type: forall w122 v122 x122 . w122 : Typedef (word), v122 : Typedef (word) => IndexAccessProxy(w122, v122, x122) -> word
>> Checking subsumption for:
forall w122 v122 x122 . w122 : Typedef (word), v122 : Typedef (word) => IndexAccessProxy(w122, v122, x122) -> word
and
forall index map member . map : Typedef (word), index : Typedef (word) => IndexAccessProxy(map, index, member) -> word
!> Creating unique type for indexStorageSlot :: forall index map member . map : Typedef (word), index : Typedef (word) => IndexAccessProxy(map, index, member) -> word
!>>> Result:data t_indexStorageSlot6 (index, map, member) = t_indexStorageSlot6  ;
>> Starting the creation of instance for indexStorageSlot :: forall index map member . map : Typedef (word), index : Typedef (word) => IndexAccessProxy(map, index, member) -> word
>> Generated invokable instance:
forall map index member .
map : Typedef (word), index : Typedef (word) => instance t_indexStorageSlot6(index, map, member) : invokable (IndexAccessProxy(map, index, member), word) {
   map : Typedef (word), index : Typedef (word) => function invoke (self7 : t_indexStorageSlot6(index, map, member), arg8 : IndexAccessProxy(map, index, member)) -> word {
      match ((self7, arg8)) {
      | (t_indexStorageSlot6, IndexAccessProxy(p132, q132)) =>
         return indexStorageSlot(IndexAccessProxy(p132, q132));
      }
   }
}

# tcFunDef ?b135 : Typedef (word), ?c135 : Typedef (word) => function invoke (self7 : t_indexStorageSlot6(?c135, ?b135, ?d135), arg8 : IndexAccessProxy(?b135, ?c135, ?d135)) -> word
## predicates in signature:(?b135 : Typedef (word), ?c135 : Typedef (word), ?b135 : Typedef (word), ?c135 : Typedef (word))
> Reducing wanted constraints:(?c136 : Typedef (word), ?d136 : Typedef (word)) using (?c136 : Typedef (word), ?d136 : Typedef (word))
> After entailment:() - (?c136 : Typedef (word), ?d136 : Typedef (word))
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?c136 : Typedef (word), ?d136 : Typedef (word))
<!! Final simplified constraints:(?c136 : Typedef (word), ?d136 : Typedef (word))
>>! Trying to check the entailment of:(?c136 : Typedef (word), ?d136 : Typedef (word)) from:(?c136 : Typedef (word), ?d136 : Typedef (word))
>>! Simplified given constraints:(?c136 : Typedef (word), ?d136 : Typedef (word))
<<!! Unsolved:()
 - Reduced context: [?c136 : Typedef (word), ?d136 : Typedef (word)]
 - generalized inferred type: forall c136 d136 d135 . c136 : Typedef (word), d136 : Typedef (word) => t_indexStorageSlot6(d136, c136, d135) -> IndexAccessProxy(c136, d136, d135) -> word
>> Checking subsumption for:
forall c136 d136 d135 . c136 : Typedef (word), d136 : Typedef (word) => t_indexStorageSlot6(d136, c136, d135) -> IndexAccessProxy(c136, d136, d135) -> word
and
forall ?b135 : Typedef (word), ?c135 : Typedef (word) => t_indexStorageSlot6(?c135, ?b135, ?d135) -> IndexAccessProxy(?b135, ?c135, ?d135) -> word

# tcFunDef function memberAccess (x : IndexAccessProxy(?e146, ?f146, ?g146)) -> ?g146
## predicates in signature:(?f146 : Typedef (word), ?g146 : StorageType, ?e146 : Typedef (word))
> Reducing wanted constraints:(?e146 : Typedef (word), ?f146 : Typedef (word), ?p146 : StorageType) using (?f146 : Typedef (word), ?p146 : StorageType, ?e146 : Typedef (word))
> After entailment:() - (?f146 : Typedef (word), ?p146 : StorageType, ?e146 : Typedef (word))
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?f146 : Typedef (word), ?p146 : StorageType, ?e146 : Typedef (word))
<!! Final simplified constraints:(?f146 : Typedef (word), ?p146 : StorageType, ?e146 : Typedef (word))
>>! Trying to check the entailment of:(?f146 : Typedef (word), ?p146 : StorageType, ?e146 : Typedef (word)) from:(?f146 : Typedef (word), ?p146 : StorageType, ?e146 : Typedef (word))
>>! Simplified given constraints:(?f146 : Typedef (word), ?p146 : StorageType, ?e146 : Typedef (word))
<<!! Unsolved:()
 - Reduced context: [?f146 : Typedef (word), ?p146 : StorageType, ?e146 : Typedef (word)]
 - generalized inferred type: forall f146 p146 e146 . f146 : Typedef (word), p146 : StorageType, e146 : Typedef (word) => IndexAccessProxy(e146, f146, p146) -> p146
>> Checking subsumption for:
forall f146 p146 e146 . f146 : Typedef (word), p146 : StorageType, e146 : Typedef (word) => IndexAccessProxy(e146, f146, p146) -> p146
and
IndexAccessProxy(?e146, ?f146, ?g146) -> ?g146

# tcFunDef function memberAccess (x : IndexAccessProxy(storageRef(mapping(?m156, ?n156)), ?m156, ?n156)) -> storageRef(?n156)
## predicates in signature:(?m156 : Typedef (word))
> Reducing wanted constraints:(storageRef(mapping(?m156, ?v156)) : Typedef (word), ?m156 : Typedef (word)) using (?m156 : Typedef (word))
> After entailment:(storageRef(mapping(?m156, ?v156)) : Typedef (word)) - (?m156 : Typedef (word))
>> Before eliminating equalities (storageRef(mapping(?m156, ?v156)) : Typedef (word))
>> After eliminating equalities:(storageRef(mapping(?m156, ?v156)) : Typedef (word))
>>> Found instance for:storageRef(mapping(?m156, ?v156)) : Typedef (word)
>>>Instance:?w161 ~ word => storageRef(?x161) : Typedef (?w161)
>>>Subst:{?x161 +-> mapping(?m156, ?v156), ?w161 +-> word}
>> Before eliminating equalities (word ~ word)
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?m156 : Typedef (word))
<!! Final simplified constraints:(?m156 : Typedef (word))
>>! Trying to check the entailment of:(?m156 : Typedef (word)) from:(?m156 : Typedef (word))
>>! Simplified given constraints:(?m156 : Typedef (word))
<<!! Unsolved:()
 - Reduced context: [?m156 : Typedef (word)]
 - generalized inferred type: forall m156 v156 . m156 : Typedef (word) => IndexAccessProxy(storageRef(mapping(m156, v156)), m156, v156) -> storageRef(v156)
>> Checking subsumption for:
forall m156 v156 . m156 : Typedef (word) => IndexAccessProxy(storageRef(mapping(m156, v156)), m156, v156) -> storageRef(v156)
and
IndexAccessProxy(storageRef(mapping(?m156, ?n156)), ?m156, ?n156) -> storageRef(?n156)

# tcFunDef function size (x : Proxy(mapping(?d169, ?e169))) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: forall d169 e169 . Proxy(mapping(d169, e169)) -> word
>> Checking subsumption for:
forall d169 e169 . Proxy(mapping(d169, e169)) -> word
and
Proxy(mapping(?d169, ?e169)) -> word

# tcFunDef function addW (x : word, y : word)
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word -> word
>> Checking subsumption for:
word -> word -> word
and
word -> word -> ?o188
!> Creating unique type for addW :: word -> word -> word
!>>> Result:data t_addW9 = t_addW9  ;
>> Starting the creation of instance for addW :: word -> word -> word
>> Generated invokable instance:
instance t_addW9 : invokable ((word, word), word) {
   function invoke (self10 : t_addW9, arg11 : (word, word)) -> word {
      match ((self10, arg11)) {
      | (t_addW9, (p188, q188)) =>
         return addW(p188, q188);
      }
   }
}

# tcFunDef function invoke (self10 : t_addW9, arg11 : (word, word)) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_addW9 -> (word, word) -> word
>> Checking subsumption for:
t_addW9 -> (word, word) -> word
and
t_addW9 -> (word, word) -> word

# tcFunDef function memberAccess (x : MemberAccessProxy(ContractStorage(?v201), ?w201, ?y201)) -> ?x201
## predicates in signature:(StructField(ContractStorage(?v201), ?w201) : StructField (?x201, ?y201), ?x201 : StorageType, ?y201 : StorageSize)
> Reducing wanted constraints:(?y201 : StorageSize, ?x201 : StorageType) using (StructField(ContractStorage(?v201), ?w201) : StructField (?x201, ?y201), ?x201 : StorageType, ?y201 : StorageSize)
> After entailment:() - (StructField(ContractStorage(?v201), ?w201) : StructField (?x201, ?y201), ?x201 : StorageType, ?y201 : StorageSize)
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (StructField(ContractStorage(?v201), ?w201) : StructField (?x201, ?y201), ?x201 : StorageType, ?y201 : StorageSize)
<!! Final simplified constraints:(StructField(ContractStorage(?v201), ?w201) : StructField (?x201, ?y201), ?x201 : StorageType, ?y201 : StorageSize)
>>! Trying to check the entailment of:(StructField(ContractStorage(?v201), ?w201) : StructField (?x201, ?y201), ?x201 : StorageType, ?y201 : StorageSize) from:(StructField(ContractStorage(?v201), ?w201) : StructField (?x201, ?y201), ?x201 : StorageType, ?y201 : StorageSize)
>>! Simplified given constraints:(StructField(ContractStorage(?v201), ?w201) : StructField (?x201, ?y201), ?x201 : StorageType, ?y201 : StorageSize)
<<!! Unsolved:()
 - Reduced context: [StructField(ContractStorage(?v201), ?w201) : StructField (?x201, ?y201), ?x201 : StorageType, ?y201 : StorageSize]
 - generalized inferred type: forall v201 w201 x201 y201 . StructField(ContractStorage(v201), w201) : StructField (x201, y201), x201 : StorageType, y201 : StorageSize => MemberAccessProxy(ContractStorage(v201), w201, y201) -> x201
>> Checking subsumption for:
forall v201 w201 x201 y201 . StructField(ContractStorage(v201), w201) : StructField (x201, y201), x201 : StorageType, y201 : StorageSize => MemberAccessProxy(ContractStorage(v201), w201, y201) -> x201
and
MemberAccessProxy(ContractStorage(?v201), ?w201, ?y201) -> ?x201

# tcFunDef function memberAccess (x : MemberAccessProxy(ContractStorage(?n212), ?o212, ?q212)) -> storageRef(?p212)
## predicates in signature:(StructField(ContractStorage(?n212), ?o212) : StructField (?p212, ?q212), ?q212 : StorageSize)
> Reducing wanted constraints:(?q212 : StorageSize) using (StructField(ContractStorage(?n212), ?o212) : StructField (?z212, ?q212), ?q212 : StorageSize)
> After entailment:() - (StructField(ContractStorage(?n212), ?o212) : StructField (?z212, ?q212), ?q212 : StorageSize)
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (StructField(ContractStorage(?n212), ?o212) : StructField (?z212, ?q212), ?q212 : StorageSize)
<!! Final simplified constraints:(StructField(ContractStorage(?n212), ?o212) : StructField (?z212, ?q212), ?q212 : StorageSize)
>>! Trying to check the entailment of:(StructField(ContractStorage(?n212), ?o212) : StructField (?z212, ?q212), ?q212 : StorageSize) from:(StructField(ContractStorage(?n212), ?o212) : StructField (?z212, ?q212), ?q212 : StorageSize)
>>! Simplified given constraints:(StructField(ContractStorage(?n212), ?o212) : StructField (?z212, ?q212), ?q212 : StorageSize)
<<!! Unsolved:()
 - Reduced context: [StructField(ContractStorage(?n212), ?o212) : StructField (?z212, ?q212), ?q212 : StorageSize]
 - generalized inferred type: forall n212 o212 z212 q212 . StructField(ContractStorage(n212), o212) : StructField (z212, q212), q212 : StorageSize => MemberAccessProxy(ContractStorage(n212), o212, q212) -> storageRef(z212)
>> Checking subsumption for:
forall n212 o212 z212 q212 . StructField(ContractStorage(n212), o212) : StructField (z212, q212), q212 : StorageSize => MemberAccessProxy(ContractStorage(n212), o212, q212) -> storageRef(z212)
and
MemberAccessProxy(ContractStorage(?n212), ?o212, ?q212) -> storageRef(?p212)

# tcFunDef function size (x : Proxy((?f223, ?g223))) -> word
## predicates in signature:(?f223 : StorageSize, ?g223 : StorageSize)
> Reducing wanted constraints:(?f223 : StorageSize, ?g223 : StorageSize) using (?f223 : StorageSize, ?g223 : StorageSize)
> After entailment:() - (?f223 : StorageSize, ?g223 : StorageSize)
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?f223 : StorageSize, ?g223 : StorageSize)
<!! Final simplified constraints:(?f223 : StorageSize, ?g223 : StorageSize)
>>! Trying to check the entailment of:(?f223 : StorageSize, ?g223 : StorageSize) from:(?f223 : StorageSize, ?g223 : StorageSize)
>>! Simplified given constraints:(?f223 : StorageSize, ?g223 : StorageSize)
<<!! Unsolved:()
 - Reduced context: [?f223 : StorageSize, ?g223 : StorageSize]
 - generalized inferred type: forall f223 g223 . f223 : StorageSize, g223 : StorageSize => Proxy((f223, g223)) -> word
>> Checking subsumption for:
forall f223 g223 . f223 : StorageSize, g223 : StorageSize => Proxy((f223, g223)) -> word
and
Proxy((?f223, ?g223)) -> word

# tcFunDef function assign (l : storageRef(?q233), y : ?q233) -> ()
## predicates in signature:(?q233 : StorageType)
> Reducing wanted constraints:(?q233 : StorageType, storageRef(?q233) : Typedef (word)) using (?q233 : StorageType)
> After entailment:(storageRef(?q233) : Typedef (word)) - (?q233 : StorageType)
>> Before eliminating equalities (storageRef(?q233) : Typedef (word))
>> After eliminating equalities:(storageRef(?q233) : Typedef (word))
>>> Found instance for:storageRef(?q233) : Typedef (word)
>>>Instance:?a239 ~ word => storageRef(?b239) : Typedef (?a239)
>>>Subst:{?b239 +-> ?q233, ?a239 +-> word}
>> Before eliminating equalities (word ~ word)
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?q233 : StorageType)
<!! Final simplified constraints:(?q233 : StorageType)
>>! Trying to check the entailment of:(?q233 : StorageType) from:(?q233 : StorageType)
>>! Simplified given constraints:(?q233 : StorageType)
<<!! Unsolved:()
 - Reduced context: [?q233 : StorageType]
 - generalized inferred type: forall q233 . q233 : StorageType => storageRef(q233) -> q233 -> ()
>> Checking subsumption for:
forall q233 . q233 : StorageType => storageRef(q233) -> q233 -> ()
and
storageRef(?q233) -> ?q233 -> ()

# tcFunDef function rep (x : storageRef(?l246)) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: forall l246 . storageRef(l246) -> word
>> Checking subsumption for:
forall l246 . storageRef(l246) -> word
and
storageRef(?l246) -> word

# tcFunDef function abs (x : word) -> storageRef(?l246)
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: forall m256 . word -> storageRef(m256)
>> Checking subsumption for:
forall m256 . word -> storageRef(m256)
and
word -> storageRef(?l246)

# tcFunDef function rep (x : storage(?p266)) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: forall p266 . storage(p266) -> word
>> Checking subsumption for:
forall p266 . storage(p266) -> word
and
storage(?p266) -> word

# tcFunDef function abs (x : word) -> storage(?p266)
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: forall q276 . word -> storage(q276)
>> Checking subsumption for:
forall q276 . word -> storage(q276)
and
word -> storage(?p266)

# tcFunDef function assign (l : ref(?t286), r : ?t286) -> ()
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: forall t286 . ref(t286) -> t286 -> ()
>> Checking subsumption for:
forall t286 . ref(t286) -> t286 -> ()
and
ref(?t286) -> ?t286 -> ()

# tcFunDef function rep (x : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word
>> Checking subsumption for:
word -> word
and
word -> word

# tcFunDef function abs (x : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word
>> Checking subsumption for:
word -> word
and
word -> word

# tcFunDef function rep (x : uint) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: uint -> word
>> Checking subsumption for:
uint -> word
and
uint -> word

# tcFunDef function abs (x : word) -> uint
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> uint
>> Checking subsumption for:
word -> uint
and
word -> uint

# tcFunDef function rep (x : address) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: address -> word
>> Checking subsumption for:
address -> word
and
address -> word

# tcFunDef function abs (x : word) -> address
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> address
>> Checking subsumption for:
word -> address
and
word -> address

# tcFunDef function sload (ptr : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word
>> Checking subsumption for:
word -> word
and
word -> word

# tcFunDef function store (ptr : word, value : word) -> ()
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word -> ()
>> Checking subsumption for:
word -> word -> ()
and
word -> word -> ()

# tcFunDef function sstore_ (a : word, v : word)
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word -> ()
>> Checking subsumption for:
word -> word -> ()
and
word -> word -> ?h387
!> Creating unique type for sstore_ :: word -> word -> ()
!>>> Result:data t_sstore_12 = t_sstore_12  ;
>> Starting the creation of instance for sstore_ :: word -> word -> ()
>> Generated invokable instance:
instance t_sstore_12 : invokable ((word, word), ()) {
   function invoke (self13 : t_sstore_12, arg14 : (word, word)) -> () {
      match ((self13, arg14)) {
      | (t_sstore_12, (i387, j387)) =>
         return sstore_(i387, j387);
      }
   }
}

# tcFunDef function invoke (self13 : t_sstore_12, arg14 : (word, word)) -> ()
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_sstore_12 -> (word, word) -> ()
>> Checking subsumption for:
t_sstore_12 -> (word, word) -> ()
and
t_sstore_12 -> (word, word) -> ()

# tcFunDef function sload_ (x : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word
>> Checking subsumption for:
word -> word
and
word -> word
!> Creating unique type for sload_ :: word -> word
!>>> Result:data t_sload_15 = t_sload_15  ;
>> Starting the creation of instance for sload_ :: word -> word
>> Generated invokable instance:
instance t_sload_15 : invokable (word, word) {
   function invoke (self16 : t_sload_15, arg17 : word) -> word {
      match ((self16, arg17)) {
      | (t_sload_15, w410) =>
         return sload_(w410);
      }
   }
}

# tcFunDef function invoke (self16 : t_sload_15, arg17 : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_sload_15 -> word -> word
>> Checking subsumption for:
t_sload_15 -> word -> word
and
t_sload_15 -> word -> word

# tcFunDef function sload (ptr : word) -> uint
## predicates in signature:()
> Reducing wanted constraints:(uint : Typedef (word)) using ()
> After entailment:(uint : Typedef (word)) - ()
>> Before eliminating equalities (uint : Typedef (word))
>> After eliminating equalities:(uint : Typedef (word))
>>> Found instance for:uint : Typedef (word)
>>>Instance:?u429 ~ word => uint : Typedef (?u429)
>>>Subst:{?u429 +-> word}
>> Before eliminating equalities (word ~ word)
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> uint
>> Checking subsumption for:
word -> uint
and
word -> uint

# tcFunDef function store (ptr : word, value : uint) -> ()
## predicates in signature:()
> Reducing wanted constraints:(uint : Typedef (word)) using ()
> After entailment:(uint : Typedef (word)) - ()
>> Before eliminating equalities (uint : Typedef (word))
>> After eliminating equalities:(uint : Typedef (word))
>>> Found instance for:uint : Typedef (word)
>>>Instance:?v442 ~ word => uint : Typedef (?v442)
>>>Subst:{?v442 +-> word}
>> Before eliminating equalities (word ~ word)
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> uint -> ()
>> Checking subsumption for:
word -> uint -> ()
and
word -> uint -> ()

# tcFunDef function sload (ptr : word) -> address
## predicates in signature:()
> Reducing wanted constraints:(address : Typedef (word)) using ()
> After entailment:(address : Typedef (word)) - ()
>> Before eliminating equalities (address : Typedef (word))
>> After eliminating equalities:(address : Typedef (word))
>>> Found instance for:address : Typedef (word)
>>>Instance:?z455 ~ word => address : Typedef (?z455)
>>>Subst:{?z455 +-> word}
>> Before eliminating equalities (word ~ word)
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> address
>> Checking subsumption for:
word -> address
and
word -> address

# tcFunDef function store (ptr : word, value : address) -> ()
## predicates in signature:()
> Reducing wanted constraints:(address : Typedef (word)) using ()
> After entailment:(address : Typedef (word)) - ()
>> Before eliminating equalities (address : Typedef (word))
>> After eliminating equalities:(address : Typedef (word))
>>> Found instance for:address : Typedef (word)
>>>Instance:?a469 ~ word => address : Typedef (?a469)
>>>Subst:{?a469 +-> word}
>> Before eliminating equalities (word ~ word)
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> address -> ()
>> Checking subsumption for:
word -> address -> ()
and
word -> address -> ()

# tcFunDef function size (x : Proxy(word)) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: Proxy(word) -> word
>> Checking subsumption for:
Proxy(word) -> word
and
Proxy(word) -> word

# tcFunDef function size (x : Proxy(uint)) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: Proxy(uint) -> word
>> Checking subsumption for:
Proxy(uint) -> word
and
Proxy(uint) -> word

# tcFunDef function size (x : Proxy(address)) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: Proxy(address) -> word
>> Checking subsumption for:
Proxy(address) -> word
and
Proxy(address) -> word

# tcFunDef function size (x : Proxy(())) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: Proxy(()) -> word
>> Checking subsumption for:
Proxy(()) -> word
and
Proxy(()) -> word

# tcFunDef function toBool (x : word)
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> Bool
>> Checking subsumption for:
word -> Bool
and
word -> ?o528
!> Creating unique type for toBool :: word -> Bool
!>>> Result:data t_toBool18 = t_toBool18  ;
>> Starting the creation of instance for toBool :: word -> Bool
>> Generated invokable instance:
instance t_toBool18 : invokable (word, Bool) {
   function invoke (self19 : t_toBool18, arg20 : word) -> Bool {
      match ((self19, arg20)) {
      | (t_toBool18, p528) =>
         return toBool(p528);
      }
   }
}

# tcFunDef function invoke (self19 : t_toBool18, arg20 : word) -> Bool
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_toBool18 -> word -> Bool
>> Checking subsumption for:
t_toBool18 -> word -> Bool
and
t_toBool18 -> word -> Bool

# tcFunDef function toWord (x : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word
>> Checking subsumption for:
word -> word
and
word -> word

# tcFunDef function fromWord (x : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word
>> Checking subsumption for:
word -> word
and
word -> word

# tcFunDef function add (x : word, y : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word -> word
>> Checking subsumption for:
word -> word -> word
and
word -> word -> word

# tcFunDef function sub (x : word, y : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word -> word
>> Checking subsumption for:
word -> word -> word
and
word -> word -> word

# tcFunDef function gt (x : word, y : word) -> Bool
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word -> Bool
>> Checking subsumption for:
word -> word -> Bool
and
word -> word -> Bool

# tcFunDef function subW (x : word, y : word)
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word -> word
>> Checking subsumption for:
word -> word -> word
and
word -> word -> ?p605
!> Creating unique type for subW :: word -> word -> word
!>>> Result:data t_subW21 = t_subW21  ;
>> Starting the creation of instance for subW :: word -> word -> word
>> Generated invokable instance:
instance t_subW21 : invokable ((word, word), word) {
   function invoke (self22 : t_subW21, arg23 : (word, word)) -> word {
      match ((self22, arg23)) {
      | (t_subW21, (q605, r605)) =>
         return subW(q605, r605);
      }
   }
}

# tcFunDef function invoke (self22 : t_subW21, arg23 : (word, word)) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_subW21 -> (word, word) -> word
>> Checking subsumption for:
t_subW21 -> (word, word) -> word
and
t_subW21 -> (word, word) -> word

# tcFunDef function toWord (x : uint) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: uint -> word
>> Checking subsumption for:
uint -> word
and
uint -> word

# tcFunDef function fromWord (x : word) -> uint
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> uint
>> Checking subsumption for:
word -> uint
and
word -> uint

# tcFunDef function add (x : uint, y : uint) -> uint
## predicates in signature:()
> Reducing wanted constraints:(uint : Num) using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: uint -> uint -> uint
>> Checking subsumption for:
uint -> uint -> uint
and
uint -> uint -> uint

# tcFunDef function sub (x : uint, y : uint) -> uint
## predicates in signature:()
> Reducing wanted constraints:(uint : Num) using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: uint -> uint -> uint
>> Checking subsumption for:
uint -> uint -> uint
and
uint -> uint -> uint

# tcFunDef function gt (x : uint, y : uint) -> Bool
## predicates in signature:()
> Reducing wanted constraints:(word : Num, uint : Num) using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: uint -> uint -> Bool
>> Checking subsumption for:
uint -> uint -> Bool
and
uint -> uint -> Bool

# tcFunDef function eq (x : word, y : word) -> Bool
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word -> Bool
>> Checking subsumption for:
word -> word -> Bool
and
word -> word -> Bool

# tcFunDef function eq (x : uint, y : uint) -> Bool
## predicates in signature:()
> Reducing wanted constraints:(word : Eq, uint : Num) using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: uint -> uint -> Bool
>> Checking subsumption for:
uint -> uint -> Bool
and
uint -> uint -> Bool

# tcFunDef function eq (x : address, y : address) -> Bool
## predicates in signature:()
> Reducing wanted constraints:(?q696 : Eq, address : Typedef (?q696), address : Typedef (?q696)) using ()
> After entailment:(?q696 : Eq, address : Typedef (?q696), address : Typedef (?q696)) - ()
>> Before eliminating equalities (?q696 : Eq, address : Typedef (?q696), address : Typedef (?q696))
>> After eliminating equalities:(address : Typedef (?q696), address : Typedef (?q696), ?q696 : Eq)
>>> Found instance for:address : Typedef (?q696)
>>>Instance:?v701 ~ word => address : Typedef (?v701)
>>>Subst:{?q696 +-> ?v701}
>> Before eliminating equalities (?v701 ~ word)
>> After eliminating equalities:()
>>> Found instance for:address : Typedef (word)
>>>Instance:?r704 ~ word => address : Typedef (?r704)
>>>Subst:{?r704 +-> word}
>> Before eliminating equalities (word ~ word)
>> After eliminating equalities:()
>>> Found instance for:word : Eq
>>>Instance:word : Eq
>>>Subst:{}
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: address -> address -> Bool
>> Checking subsumption for:
address -> address -> Bool
and
address -> address -> Bool

# tcFunDef forall a b .
a : RValueMemberAccess (b) => function rval (x : a) -> b
## predicates in signature:(?x715 : RValueMemberAccess (?y715))
> Reducing wanted constraints:(?x715 : RValueMemberAccess (?c716)) using (?x715 : RValueMemberAccess (?c716))
> After entailment:() - (?x715 : RValueMemberAccess (?c716))
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?x715 : RValueMemberAccess (?c716))
<!! Final simplified constraints:(?x715 : RValueMemberAccess (?c716))
>>! Trying to check the entailment of:(?x715 : RValueMemberAccess (?c716)) from:(?x715 : RValueMemberAccess (?c716))
>>! Simplified given constraints:(?x715 : RValueMemberAccess (?c716))
<<!! Unsolved:()
 - Reduced context: [?x715 : RValueMemberAccess (?c716)]
 - generalized inferred type: forall x715 c716 . x715 : RValueMemberAccess (c716) => x715 -> c716
>> Checking subsumption for:
forall x715 c716 . x715 : RValueMemberAccess (c716) => x715 -> c716
and
forall a b . a : RValueMemberAccess (b) => a -> b
!> Creating unique type for rval :: forall a b . a : RValueMemberAccess (b) => a -> b
!>>> Result:data t_rval24 (a, b) = t_rval24  ;
>> Starting the creation of instance for rval :: forall a b . a : RValueMemberAccess (b) => a -> b
>> Generated invokable instance:
forall a b .
a : RValueMemberAccess (b) => instance t_rval24(a, b) : invokable (a, b) {
   a : RValueMemberAccess (b) => function invoke (self25 : t_rval24(a, b), arg26 : a) -> b {
      match ((self25, arg26)) {
      | (t_rval24, x726) =>
         return rval(x726);
      }
   }
}

# tcFunDef ?x729 : RValueMemberAccess (?y729) => function invoke (self25 : t_rval24(?x729, ?y729), arg26 : ?x729) -> ?y729
## predicates in signature:(?x729 : RValueMemberAccess (?y729), ?x729 : RValueMemberAccess (?y729))
> Reducing wanted constraints:(?e730 : RValueMemberAccess (?g730)) using (?e730 : RValueMemberAccess (?g730))
> After entailment:() - (?e730 : RValueMemberAccess (?g730))
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?e730 : RValueMemberAccess (?g730))
<!! Final simplified constraints:(?e730 : RValueMemberAccess (?g730))
>>! Trying to check the entailment of:(?e730 : RValueMemberAccess (?g730)) from:(?e730 : RValueMemberAccess (?g730))
>>! Simplified given constraints:(?e730 : RValueMemberAccess (?g730))
<<!! Unsolved:()
 - Reduced context: [?e730 : RValueMemberAccess (?g730)]
 - generalized inferred type: forall e730 g730 . e730 : RValueMemberAccess (g730) => t_rval24(e730, g730) -> e730 -> g730
>> Checking subsumption for:
forall e730 g730 . e730 : RValueMemberAccess (g730) => t_rval24(e730, g730) -> e730 -> g730
and
forall ?x729 : RValueMemberAccess (?y729) => t_rval24(?x729, ?y729) -> ?x729 -> ?y729

# tcFunDef function or (x : Bool, y : Bool) -> Bool
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: Bool -> Bool -> Bool
>> Checking subsumption for:
Bool -> Bool -> Bool
and
Bool -> Bool -> Bool
!> Creating unique type for or :: Bool -> Bool -> Bool
!>>> Result:data t_or27 = t_or27  ;
>> Starting the creation of instance for or :: Bool -> Bool -> Bool
>> Generated invokable instance:
instance t_or27 : invokable ((Bool, Bool), Bool) {
   function invoke (self28 : t_or27, arg29 : (Bool, Bool)) -> Bool {
      match ((self28, arg29)) {
      | (t_or27, (h753, i753)) =>
         return or(h753, i753);
      }
   }
}

# tcFunDef function invoke (self28 : t_or27, arg29 : (Bool, Bool)) -> Bool
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_or27 -> (Bool, Bool) -> Bool
>> Checking subsumption for:
t_or27 -> (Bool, Bool) -> Bool
and
t_or27 -> (Bool, Bool) -> Bool

# tcFunDef forall a .
a : Num => function ge (x : a, y : a) -> Bool
## predicates in signature:(?r768 : Num)
> Reducing wanted constraints:(?r768 : Num, ?r768 : Eq) using (?r768 : Num)
> After entailment:() - (?r768 : Num, ?r768 : Eq)
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?r768 : Num, ?r768 : Eq)
<!! Final simplified constraints:(?r768 : Num, ?r768 : Eq, ?r768 : Eq)
>>! Trying to check the entailment of:(?r768 : Num, ?r768 : Eq, ?r768 : Eq) from:(?r768 : Num, ?r768 : Eq)
>>! Simplified given constraints:(?r768 : Num, ?r768 : Eq)
<<!! Unsolved:()
 - Reduced context: [?r768 : Num, ?r768 : Eq, ?r768 : Eq]
 - generalized inferred type: forall r768 . r768 : Num, r768 : Eq, r768 : Eq => r768 -> r768 -> Bool
>> Checking subsumption for:
forall r768 . r768 : Num, r768 : Eq, r768 : Eq => r768 -> r768 -> Bool
and
forall a . a : Num => a -> a -> Bool
!> Creating unique type for ge :: forall a . a : Num => a -> a -> Bool
!>>> Result:data t_ge30 (a) = t_ge30  ;
>> Starting the creation of instance for ge :: forall a . a : Num => a -> a -> Bool
>> Generated invokable instance:
forall a .
a : Num => instance t_ge30(a) : invokable ((a, a), Bool) {
   a : Num => function invoke (self31 : t_ge30(a), arg32 : (a, a)) -> Bool {
      match ((self31, arg32)) {
      | (t_ge30, (i780, j780)) =>
         return ge(i780, j780);
      }
   }
}

# tcFunDef ?p783 : Num => function invoke (self31 : t_ge30(?p783), arg32 : (?p783, ?p783)) -> Bool
## predicates in signature:(?p783 : Num, ?p783 : Num)
> Reducing wanted constraints:(?p783 : Num) using (?p783 : Num)
> After entailment:() - (?p783 : Num, ?p783 : Eq)
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?p783 : Num, ?p783 : Eq)
<!! Final simplified constraints:(?p783 : Num, ?p783 : Eq, ?p783 : Eq)
>>! Trying to check the entailment of:(?p783 : Num, ?p783 : Eq, ?p783 : Eq) from:(?p783 : Num, ?p783 : Eq)
>>! Simplified given constraints:(?p783 : Num, ?p783 : Eq)
<<!! Unsolved:()
 - Reduced context: [?p783 : Num, ?p783 : Eq, ?p783 : Eq]
 - generalized inferred type: forall p783 . p783 : Num, p783 : Eq, p783 : Eq => t_ge30(p783) -> (p783, p783) -> Bool
>> Checking subsumption for:
forall p783 . p783 : Num, p783 : Eq, p783 : Eq => t_ge30(p783) -> (p783, p783) -> Bool
and
forall ?p783 : Num => t_ge30(?p783) -> (?p783, ?p783) -> Bool

# tcFunDef function not (b : Bool) -> Bool
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: Bool -> Bool
>> Checking subsumption for:
Bool -> Bool
and
Bool -> Bool
!> Creating unique type for not :: Bool -> Bool
!>>> Result:data t_not33 = t_not33  ;
>> Starting the creation of instance for not :: Bool -> Bool
>> Generated invokable instance:
instance t_not33 : invokable (Bool, Bool) {
   function invoke (self34 : t_not33, arg35 : Bool) -> Bool {
      match ((self34, arg35)) {
      | (t_not33, d808) =>
         return not(d808);
      }
   }
}

# tcFunDef function invoke (self34 : t_not33, arg35 : Bool) -> Bool
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_not33 -> Bool -> Bool
>> Checking subsumption for:
t_not33 -> Bool -> Bool
and
t_not33 -> Bool -> Bool

# tcFunDef forall a .
a : Eq => function ne (x : a, y : a)
## predicates in signature:(?c824 : Eq)
> Reducing wanted constraints:(?c824 : Eq) using (?c824 : Eq)
> After entailment:() - (?c824 : Eq)
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?c824 : Eq)
<!! Final simplified constraints:(?c824 : Eq)
>>! Trying to check the entailment of:(?c824 : Eq) from:(?c824 : Eq)
>>! Simplified given constraints:(?c824 : Eq)
<<!! Unsolved:()
 - Reduced context: [?c824 : Eq]
 - generalized inferred type: forall c824 . c824 : Eq => c824 -> c824 -> Bool
>> Checking subsumption for:
forall c824 . c824 : Eq => c824 -> c824 -> Bool
and
forall a . a : Eq => a -> a -> ?f836
!> Creating unique type for ne :: forall a . a : Eq => a -> a -> Bool
!>>> Result:data t_ne36 (a) = t_ne36  ;
>> Starting the creation of instance for ne :: forall a . a : Eq => a -> a -> Bool
>> Generated invokable instance:
forall a .
a : Eq => instance t_ne36(a) : invokable ((a, a), Bool) {
   a : Eq => function invoke (self37 : t_ne36(a), arg38 : (a, a)) -> Bool {
      match ((self37, arg38)) {
      | (t_ne36, (i836, j836)) =>
         return ne(i836, j836);
      }
   }
}

# tcFunDef ?u839 : Eq => function invoke (self37 : t_ne36(?u839), arg38 : (?u839, ?u839)) -> Bool
## predicates in signature:(?u839 : Eq, ?u839 : Eq)
> Reducing wanted constraints:(?u839 : Eq) using (?u839 : Eq)
> After entailment:() - (?u839 : Eq)
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using (?u839 : Eq)
<!! Final simplified constraints:(?u839 : Eq)
>>! Trying to check the entailment of:(?u839 : Eq) from:(?u839 : Eq)
>>! Simplified given constraints:(?u839 : Eq)
<<!! Unsolved:()
 - Reduced context: [?u839 : Eq]
 - generalized inferred type: forall u839 . u839 : Eq => t_ne36(u839) -> (u839, u839) -> Bool
>> Checking subsumption for:
forall u839 . u839 : Eq => t_ne36(u839) -> (u839, u839) -> Bool
and
forall ?u839 : Eq => t_ne36(?u839) -> (?u839, ?u839) -> Bool
# tiFunDef:function require1fail ()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
>>> Infered type for require1fail :: ()
!> Creating unique type for require1fail :: ()
!>>> Result:data t_require1fail39 = t_require1fail39  ;
>> Starting the creation of instance for require1fail :: ()
>> Generated invokable instance:
instance t_require1fail39 : invokable ((), ()) {
   function invoke (self40 : t_require1fail39, arg41 : ()) -> () {
      match ((self40, arg41)) {
      | (t_require1fail39, n865) =>
         return require1fail();
      }
   }
}

# tcFunDef function invoke (self40 : t_require1fail39, arg41 : ()) -> ()
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_require1fail39 -> () -> ()
>> Checking subsumption for:
t_require1fail39 -> () -> ()
and
t_require1fail39 -> () -> ()

# tcFunDef function require1 (cond : Bool)
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: Bool -> ()
>> Checking subsumption for:
Bool -> ()
and
Bool -> ?x894
!> Creating unique type for require1 :: Bool -> ()
!>>> Result:data t_require142 = t_require142  ;
>> Starting the creation of instance for require1 :: Bool -> ()
>> Generated invokable instance:
instance t_require142 : invokable (Bool, ()) {
   function invoke (self43 : t_require142, arg44 : Bool) -> () {
      match ((self43, arg44)) {
      | (t_require142, y894) =>
         return require1(y894);
      }
   }
}

# tcFunDef function invoke (self43 : t_require142, arg44 : Bool) -> ()
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_require142 -> Bool -> ()
>> Checking subsumption for:
t_require142 -> Bool -> ()
and
t_require142 -> Bool -> ()

# tcFunDef function nop () -> ()
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: ()
>> Checking subsumption for:
()
and
()
!> Creating unique type for nop :: ()
!>>> Result:data t_nop45 = t_nop45  ;
>> Starting the creation of instance for nop :: ()
>> Generated invokable instance:
instance t_nop45 : invokable ((), ()) {
   function invoke (self46 : t_nop45, arg47 : ()) -> () {
      match ((self46, arg47)) {
      | (t_nop45, t924) =>
         return nop();
      }
   }
}

# tcFunDef function invoke (self46 : t_nop45, arg47 : ()) -> ()
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_nop45 -> () -> ()
>> Checking subsumption for:
t_nop45 -> () -> ()
and
t_nop45 -> () -> ()

# tcFunDef function hash1 (x : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: word -> word
>> Checking subsumption for:
word -> word
and
word -> word
!> Creating unique type for hash1 :: word -> word
!>>> Result:data t_hash148 = t_hash148  ;
>> Starting the creation of instance for hash1 :: word -> word
>> Generated invokable instance:
instance t_hash148 : invokable (word, word) {
   function invoke (self49 : t_hash148, arg50 : word) -> word {
      match ((self49, arg50)) {
      | (t_hash148, d955) =>
         return hash1(d955);
      }
   }
}

# tcFunDef function invoke (self49 : t_hash148, arg50 : word) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_hash148 -> word -> word
>> Checking subsumption for:
t_hash148 -> word -> word
and
t_hash148 -> word -> word
# tiFunDef:function fromBool (b)
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
>>> Infered type for fromBool :: Bool -> word
!> Creating unique type for fromBool :: Bool -> word
!>>> Result:data t_fromBool51 = t_fromBool51  ;
>> Starting the creation of instance for fromBool :: Bool -> word
>> Generated invokable instance:
instance t_fromBool51 : invokable (Bool, word) {
   function invoke (self52 : t_fromBool51, arg53 : Bool) -> word {
      match ((self52, arg53)) {
      | (t_fromBool51, b986) =>
         return fromBool(b986);
      }
   }
}

# tcFunDef function invoke (self52 : t_fromBool51, arg53 : Bool) -> word
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_fromBool51 -> Bool -> word
>> Checking subsumption for:
t_fromBool51 -> Bool -> word
and
t_fromBool51 -> Bool -> word

# tcFunDef function caller () -> address
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: address
>> Checking subsumption for:
address
and
address
!> Creating unique type for caller :: address
!>>> Result:data t_caller54 = t_caller54  ;
>> Starting the creation of instance for caller :: address
>> Generated invokable instance:
instance t_caller54 : invokable ((), address) {
   function invoke (self55 : t_caller54, arg56 : ()) -> address {
      match ((self55, arg56)) {
      | (t_caller54, n1017) =>
         return caller();
      }
   }
}

# tcFunDef function invoke (self55 : t_caller54, arg56 : ()) -> address
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_caller54 -> () -> address
>> Checking subsumption for:
t_caller54 -> () -> address
and
t_caller54 -> () -> address

# tcFunDef function addU (x : uint, y : uint) -> uint
## predicates in signature:()
> Reducing wanted constraints:(uint : Num, uint : Num) using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: uint -> uint -> uint
>> Checking subsumption for:
uint -> uint -> uint
and
uint -> uint -> uint
!> Creating unique type for addU :: uint -> uint -> uint
!>>> Result:data t_addU57 = t_addU57  ;
>> Starting the creation of instance for addU :: uint -> uint -> uint
>> Generated invokable instance:
instance t_addU57 : invokable ((uint, uint), uint) {
   function invoke (self58 : t_addU57, arg59 : (uint, uint)) -> uint {
      match ((self58, arg59)) {
      | (t_addU57, (uint(r1049), uint(s1049))) =>
         return addU(uint(r1049), uint(s1049));
      }
   }
}

# tcFunDef function invoke (self58 : t_addU57, arg59 : (uint, uint)) -> uint
## predicates in signature:()
> Reducing wanted constraints:() using ()
> After entailment:() - ()
>> Before eliminating equalities ()
>> After eliminating equalities:()
< Reduced by instances constraints:()
>!! Simplifying () using ()
<!! Final simplified constraints:()
>>! Trying to check the entailment of:() from:()
>>! Simplified given constraints:()
<<!! Unsolved:()
 - Reduced context: []
 - generalized inferred type: t_addU57 -> (uint, uint) -> uint
>> Checking subsumption for:
t_addU57 -> (uint, uint) -> uint
and
t_addU57 -> (uint, uint) -> uint

# tcFunDef function withdraw (src : address, amt : uint)
## predicates in signature:()
> Reducing wanted constraints:(?w1068 : Assign (uint), IndexAccessProxy(?i1069, address, ?k1069) : LValueMemberAccess (?w1068), MemberAccessProxy(ContractStorage(UintCxt), balances_sel, ?g1069) : LValueMemberAccess (?i1069), uint : Num, IndexAccessProxy(?c1070, address, ?e1070) : RValueMemberAccess (uint), MemberAccessProxy(ContractStorage(UintCxt), balances_sel, ?a1070) : LValueMemberAccess (?c1070)) using ()
> After entailment:(?w1068 : Assign (uint), IndexAccessProxy(?i1069, address, ?k1069) : LValueMemberAccess (?w1068), MemberAccessProxy(ContractStorage(UintCxt), balances_sel, ?g1069) : LValueMemberAccess (?i1069), IndexAccessProxy(?c1070, address, ?e1070) : RValueMemberAccess (uint), MemberAccessProxy(ContractStorage(UintCxt), balances_sel, ?a1070) : LValueMemberAccess (?c1070)) - ()
>> Before eliminating equalities (?w1068 : Assign (uint), IndexAccessProxy(?i1069, address, ?k1069) : LValueMemberAccess (?w1068), MemberAccessProxy(ContractStorage(UintCxt), balances_sel, ?g1069) : LValueMemberAccess (?i1069), IndexAccessProxy(?c1070, address, ?e1070) : RValueMemberAccess (uint), MemberAccessProxy(ContractStorage(UintCxt), balances_sel, ?a1070) : LValueMemberAccess (?c1070))
>> After eliminating equalities:(MemberAccessProxy(ContractStorage(UintCxt), balances_sel, ?a1070) : LValueMemberAccess (?c1070), IndexAccessProxy(?c1070, address, ?e1070) : RValueMemberAccess (uint), MemberAccessProxy(ContractStorage(UintCxt), balances_sel, ?g1069) : LValueMemberAccess (?i1069), IndexAccessProxy(?i1069, address, ?k1069) : LValueMemberAccess (?w1068), ?w1068 : Assign (uint))
>>> Found instance for:MemberAccessProxy(ContractStorage(UintCxt), balances_sel, ?a1070) : LValueMemberAccess (?c1070)
>>>Instance:StructField(ContractStorage(?a1075), ?b1075) : StructField (?c1075, ?d1075), ?d1075 : StorageSize, ?e1075 ~ storageRef(?c1075) => MemberAccessProxy(ContractStorage(?a1075), ?b1075, ?d1075) : LValueMemberAccess (?e1075)
>>>Subst:{?a1075 +-> UintCxt, ?b1075 +-> balances_sel, ?d1075 +-> ?a1070, ?c1070 +-> ?e1075}
>> Before eliminating equalities (StructField(ContractStorage(UintCxt), balances_sel) : StructField (?c1075, ?a1070), ?a1070 : StorageSize, ?e1075 ~ storageRef(?c1075))
>> After eliminating equalities:(?a1070 : StorageSize, StructField(ContractStorage(UintCxt), balances_sel) : StructField (?c1075, ?a1070))
>>> Solving:?a1070 : StorageSize (HNF)
>>> Found instance for:StructField(ContractStorage(UintCxt), balances_sel) : StructField (?c1075, ?a1070)
>>>Instance:?c1080 ~ mapping(address, uint), ?d1080 ~ (word, (address, (address, (uint, (uint, ()))))) => StructField(ContractStorage(UintCxt), balances_sel) : StructField (?c1080, ?d1080)
>>>Subst:{?c1075 +-> ?c1080, ?a1070 +-> ?d1080}
>> Before eliminating equalities (?c1080 ~ mapping(address, uint), ?d1080 ~ (word, (address, (address, (uint, (uint, ()))))))
>> After eliminating equalities:()
>>> Found instance for:IndexAccessProxy(storageRef(mapping(address, uint)), address, ?e1070) : RValueMemberAccess (uint)
>>>Instance:?o1083 : Typedef (word), ?p1083 : StorageType, ?q1083 : Typedef (word), ?r1083 ~ ?p1083 => IndexAccessProxy(?q1083, ?o1083, ?p1083) : RValueMemberAccess (?r1083)
>>>Subst:{?q1083 +-> storageRef(mapping(address, uint)), ?o1083 +-> address, ?p1083 +-> ?e1070, ?r1083 +-> uint}
>> Before eliminating equalities (address : Typedef (word), ?e1070 : StorageType, storageRef(mapping(address, uint)) : Typedef (word), uint ~ ?e1070)
>> After eliminating equalities:(storageRef(mapping(address, uint)) : Typedef (word), uint : StorageType, address : Typedef (word))
>>> Found instance for:storageRef(mapping(address, uint)) : Typedef (word)
>>>Instance:?l1088 ~ word => storageRef(?m1088) : Typedef (?l1088)
>>>Subst:{?m1088 +-> mapping(address, uint), ?l1088 +-> word}
>> Before eliminating equalities (word ~ word)
>> After eliminating equalities:()
>>> Found instance for:uint : StorageType
>>>Instance:uint : StorageType
>>>Subst:{}
>> Before eliminating equalities ()
>> After eliminating equalities:()
>>> Found instance for:address : Typedef (word)
>>>Instance:?c1096 ~ word => address : Typedef (?c1096)
>>>Subst:{?c1096 +-> word}
>> Before eliminating equalities (word ~ word)
>> After eliminating equalities:()
>>> Found instance for:MemberAccessProxy(ContractStorage(UintCxt), balances_sel, ?g1069) : LValueMemberAccess (?i1069)
>>>Instance:StructField(ContractStorage(?o1098), ?p1098) : StructField (?q1098, ?r1098), ?r1098 : StorageSize, ?s1098 ~ storageRef(?q1098) => MemberAccessProxy(ContractStorage(?o1098), ?p1098, ?r1098) : LValueMemberAccess (?s1098)
>>>Subst:{?o1098 +-> UintCxt, ?p1098 +-> balances_sel, ?r1098 +-> ?g1069, ?i1069 +-> ?s1098}
>> Before eliminating equalities (StructField(ContractStorage(UintCxt), balances_sel) : StructField (?q1098, ?g1069), ?g1069 : StorageSize, ?s1098 ~ storageRef(?q1098))
>> After eliminating equalities:(?g1069 : StorageSize, StructField(ContractStorage(UintCxt), balances_sel) : StructField (?q1098, ?g1069))
>>> Solving:?g1069 : StorageSize (HNF)
>>> Found instance for:StructField(ContractStorage(UintCxt), balances_sel) : StructField (?q1098, ?g1069)
>>>Instance:?q1103 ~ mapping(address, uint), ?r1103 ~ (word, (address, (address, (uint, (uint, ()))))) => StructField(ContractStorage(UintCxt), balances_sel) : StructField (?q1103, ?r1103)
>>>Subst:{?q1098 +-> ?q1103, ?g1069 +-> ?r1103}
>> Before eliminating equalities (?q1103 ~ mapping(address, uint), ?r1103 ~ (word, (address, (address, (uint, (uint, ()))))))
>> After eliminating equalities:()
>>> No matching instance for:IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068) trying a default instance.
>>>> No default instance found for:IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068)
>>> Solving:?w1068 : Assign (uint) (HNF)
< Reduced by instances constraints:((word, (address, (address, (uint, (uint, ()))))) : StorageSize, (word, (address, (address, (uint, (uint, ()))))) : StorageSize, IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068), ?w1068 : Assign (uint))
>!! Simplifying ((word, (address, (address, (uint, (uint, ()))))) : StorageSize, (word, (address, (address, (uint, (uint, ()))))) : StorageSize, IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068), ?w1068 : Assign (uint)) using ()
>> Entailing: (word, (address, (address, (uint, (uint, ()))))) : StorageSize by ((word, (address, (address, (uint, (uint, ()))))) : StorageSize, IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068), ?w1068 : Assign (uint))
>> Entailing: (word, (address, (address, (uint, (uint, ()))))) : StorageSize by (IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068), ?w1068 : Assign (uint))
>>IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068) cannot be entailed by:(?w1068 : Assign (uint))
>>?w1068 : Assign (uint) cannot be entailed by:(IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068))
<!! Final simplified constraints:(?w1068 : Assign (uint), IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068))
>>! Trying to check the entailment of:(?w1068 : Assign (uint), IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068)) from:()
>>! Simplified given constraints:()
<<!! Unsolved:(?w1068 : Assign (uint), IndexAccessProxy(storageRef(mapping(address, uint)), address, ?k1069) : LValueMemberAccess (?w1068))

------------------------------------------------------------------
Cannot entail:
?w1068 : Assign (uint)
using defined instances:
ref(?l1119) : Assign (?l1119)
?m1119 : StorageType => storageRef(?m1119) : Assign (?m1119)


 - in:function withdraw (src : address, amt : uint) {
   Assign.assign(LValueMemberAccess.memberAccess(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), Num.sub(rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), amt) : uint);
}
