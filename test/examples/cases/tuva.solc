// TUVA: TUple-based Value Access
/*
# Types and classes for assignemnt desugaring
- access proxy types
- LValue and RValue access classes (LVA, RVA)
- Assign class
*/


// Would import std if it weren't for pragmas :(
// import std;

// -- relevant fragments of std

// import NumLib;
function hash2(x: word, y: word) -> word {
  let result: word = 0;
  assembly {
    mstore(0, x)
    mstore(32, y)
    result := keccak256(0,64)
  }
  return result;
}

// --- Proxy ---

// Proxy is a unit type that can be used to pass Types as paramaters at runtime
data Proxy(t) = Proxy;

// --- Type Abstraction ---

forall abs rep . class abs:Typedef(rep) {
    function abs(x:rep) -> abs;
    function rep(x:abs) -> rep;
}

// -- value types

instance word:Typedef(word) {
    function rep(x:word) -> word { return x; }
    function abs(x:word) -> word { return x; }
}

data address = address(word);

instance address:Typedef(word) {
    function rep(x:address) -> word {
        match x {
            | address(y) => return y;
        }
    }
    function abs(x:word) -> address {
        return address(x);
    }
}


// type uint = uint256;
data uint = uint(word);
instance uint:Typedef(word) {
    function abs(w: word) -> uint {
        return uint(w);
    }

    function rep(x: uint) -> word {
        match x {
        | uint(w) => return w;
        }
    }
}

data storage(t) = storage(word);
forall t . instance storage(t) : Typedef(word) {
    function abs(x: word) -> storage(t) {
        return storage(x);
    }

    function rep(x: storage(t)) -> word {
        match x {
        | storage(w) => return w;
       }
    }
}


// -- std ends


// -- storage

forall self.
class self:StorageSize {
    function size(x:Proxy(self)) -> word;
}

instance ():StorageSize {
    function size(x:Proxy(())) -> word {
        return 0;
    }
}

instance word:StorageSize {
    function size(x:Proxy(word)) -> word {
        return 1;
    }
}

instance uint:StorageSize {
    function size(x:Proxy(uint)) -> word {
        return 1;
    }
}

instance address:StorageSize {
    function size(x:Proxy(address)) -> word {
        return 1;
    }
}

forall a b . a:StorageSize, b:StorageSize => instance (a,b):StorageSize {
    function size(x:Proxy((a,b))) -> word {
        let a_sz:word = StorageSize.size(Proxy:Proxy(a));
        let b_sz:word = StorageSize.size(Proxy:Proxy(b));
        assembly {
            a_sz := add(a_sz, b_sz)
        }
        return a_sz;
    }
}


forall self.
class self:StorageType {
    function sload(ptr:word) -> self;
    function store(ptr:word, value:self) -> ();
}

instance word:StorageType {
    function sload(ptr:word) -> word {
        let r:word;
        assembly {
            r := sload(ptr);
        }
        return r;
    }
    function store(ptr:word, value:word) -> () {
        assembly {
            sstore(ptr, value)
        }
    }
}

forall a. a:Typedef(word) =>
function sloadViaWord(ptr:word) -> a {
    let r:word;
    assembly {
	r := sload(ptr);
    }
    return Typedef.abs(r);
}

forall a. a:Typedef(word) =>
function storeViaWord(ptr:word, value:a) -> () {
    let w: word = Typedef.rep(value);
    assembly {
	sstore(ptr, w)
    }
}

instance uint:StorageType {
  function sload(ptr:word) -> uint { return uint(StorageType.sload(ptr):word); }
  function store(ptr:word, value:uint) -> () { StorageType.store(ptr, Typedef.rep(value):word); }
}


// --- mappings - to be moved to std once stabilised

// data mapping(member, index) = mapping(word, Proxy(member), Proxy(index)) ;
data mapping(member, index) = mapping(word) ;

forall member index . instance mapping(index, member):Typedef(word) {
    function rep(x:mapping(index, member)) -> word {
        match x {
            | mapping(y) => return y;
        }
    }
    function abs(x:word) -> mapping(index,member) {
        return mapping(x);
    }
}

// cf https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#mappings-and-dynamic-arrays
forall index member .
instance mapping(index, member):StorageSize {
    function size(x:Proxy(mapping(index, member))) -> word {
        return 1;
    }
}

forall lhs rhs.
class lhs:Assign(rhs) {
    function assign(l:lhs, r:rhs) -> ();
}


forall a. a:StorageType =>
instance storage(a):Assign(a) {
    function assign(l:storage(a), r:a) -> () {
      StorageType.store(Typedef.rep(l), r);
    }
}

// -- Tuple-based indexed access:

forall col_idx val . class col_idx:RValueIdxAccess(val) {
  function lookup(ci : col_idx) -> val;
}

forall col_idx ref . class col_idx:LValueIdxAccess(ref) {
  function lookup(ci : col_idx) -> ref;
}

forall i a . i:Typedef(word) =>
instance (storage(mapping(i,a)), i): LValueIdxAccess(storage(a)) {
  function lookup(xi : (storage(mapping(i,a)), i)) -> storage(a) {
    match(xi) {
      | (x, i) => return storage(hash2(Typedef.rep(x), Typedef.rep(i)));
    }

    // return storage(42); // FIXME: hash2(x,i);
  }
}

forall i a . a:StorageType, i:Typedef(word) =>
instance (storage(mapping(i,a)), i): RValueIdxAccess(a) {
  function lookup(xi : (storage(mapping(i,a)), i)) -> a {
  /*
    match(xi) {
      | (x, i) => return StorageType.sload(hash2(Typedef.rep(x), Typedef.rep(i)));
    }
  */
  return readStorage(LValueIdxAccess.lookup(xi));
  }
}

forall a. a:StorageType =>
function readStorage(x:storage(a)) -> a {
  return StorageType.sload(Typedef.rep(x));
}

forall r a. r: RValueIdxAccess(a) =>
function rval(x:r) -> a {
  return RValueIdxAccess.lookup(x);
}

forall r a. r: LValueIdxAccess(a) =>
function lval(x:r) -> a {
  return LValueIdxAccess.lookup(x);
}

contract TestTuva {
  function main() -> word {
    let balances : storage(mapping(address, word));
    let allowances : storage(mapping(address, mapping(address, word) ));
    let ref1 : storage(word) = lval( (balances, address(17)) );
    Assign.assign(lval( (balances, address(1)) ), 1337);

    let ref2a // : storage( mapping(address, word) ) // omitting this type makes instance resolution fail
              = lval ( (allowances, address(1)) );

    let ref2b // : storage( word )
              = lval ( (ref2a, address(2)) );

    Assign.assign( ref2b, 777 );

//    return rval( (balances, address(1)) );
    return rval ( (ref2a, address(2)) );
  }
}
