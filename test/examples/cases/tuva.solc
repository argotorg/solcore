// TUVA: TUple-based Value Access
/*
# Types and classes for assignemnt desugaring using
- access proxy types
- LValue and RValue access classes (LVA, RVA)
- StorageType class
- Assign class
*/

import std;


forall col_idx val . class col_idx:RValueIdxAccess(val) {
  function lookup(ci : col_idx) -> val;
}

forall col_idx ref . class col_idx:LValueIdxAccess(ref) {
  function lookup(ci : col_idx) -> ref;
}

forall i a . i:Typedef(word) =>
instance (storage(mapping(i,a)), i): LValueIdxAccess(storage(a)) {
  function lookup(xi : (storage(mapping(i,a)), i)) -> storage(a) {
    match(xi) {
      | (x, i) => return storage(hash2(Typedef.rep(x), Typedef.rep(i)));
    }

    // return storage(42); // FIXME: hash2(x,i);
  }
}

forall i a . a:StorageType, i:Typedef(word) =>
instance (storage(mapping(i,a)), i): RValueIdxAccess(a) {
  function lookup(xi : (storage(mapping(i,a)), i)) -> a {
  /*
    match(xi) {
      | (x, i) => return StorageType.sload(hash2(Typedef.rep(x), Typedef.rep(i)));
    }
  */
  return readStorage(LValueIdxAccess.lookup(xi));
  }
}

forall a. a:StorageType =>
function readStorage(x:storage(a)) -> a {
  return StorageType.sload(Typedef.rep(x));
}

forall r a. r: RValueIdxAccess(a) =>
function idx_rval(x:r) -> a {
  return RValueIdxAccess.lookup(x);
}

forall r a. r: LValueIdxAccess(a) =>
function idx_lval(x:r) -> a {
  return LValueIdxAccess.lookup(x);
}

contract TestTuva {
  function main() -> word {
    let balances : storage(mapping(address, word));
    let allowances : storage(mapping(address, mapping(address, word) ));
    let ref1 : storage(word) = idx_lval( (balances, address(17)) );
    Assign.assign(idx_lval( (balances, address(1)) ), 1337);

    let ref2a // : storage( mapping(address, word) ) // omitting this type makes instance resolution fail
              = idx_lval ( (allowances, address(1)) );

    let ref2b // : storage( word )
              = idx_lval ( (ref2a, address(2)) );

    Assign.assign( ref2b, 777 );

//    return idx_rval( (balances, address(1)) );
    return idx_rval ( (ref2a, address(2)) );
  }
}
