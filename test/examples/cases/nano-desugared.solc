function addW (x : word, y : word) {
   let res : word ;
   assembly { res := add(x, y)
            }
   return res;
}
function subW (x : word, y : word) {
   let res : word ;
   assembly { res := sub(x, y)
            }
   return res;
}
function addU (x : uint, y : uint) -> uint {
   let res : word ;
   let xw : word = Num.toWord(x) ;
   let yw : word = Num.toWord(y) ;
   assembly { res := add(xw, yw)
            }
   return uint(res);
}
function hash1 (x : word) -> word {
   let result : word = 0 ;
   assembly { mstore(0, x)
              result := keccak256(0, 32)
            }
   return result;
}
function hash2 (x : word, y : word) -> word {
   let result : word = 0 ;
   assembly { mstore(0, x)
              mstore(32, y)
              result := keccak256(0, 64)
            }
   return result;
}
data Bool = False  | True  ;
function not (b : Bool) -> Bool {
   match (b) {
   | False =>
      return True;
   | True =>
      return False;
   }
}
function or (x : Bool, y : Bool) -> Bool {
   match (x) {
   | False =>
      return y;
   | True =>
      return True;
   }
}
function fromBool (b) {
   match (b) {
   | False =>
      return 0;
   | True =>
      return 1;
   }
}
function toBool (x : word) {
   match (x) {
   | 0 =>
      return False;
   | _ =>
      return True;
   }
}
forall a . class  a : Num {
   function toWord (x : a) -> word;
   function fromWord (x : word) -> a;
   function add (x : a, y : a) -> a;
   function sub (x : a, y : a) -> a;
   function eq (x : a, y : a) -> Bool;
   function gt (x : a, y : a) -> Bool;
}
instance word : Num {
   function toWord (x : word) -> word {
      return x;
   }
   function fromWord (x : word) -> word {
      return x;
   }
   function add (x : word, y : word) -> word {
      return addW(x, y);
   }
   function sub (x : word, y : word) -> word {
      return addW(x, y);
   }
   function eq (x : word, y : word) -> Bool {
      let res : word ;
      assembly { res := eq(x, y)
               }
      return toBool(res);
   }
   function gt (x : word, y : word) -> Bool {
      let res : word ;
      assembly { res := gt(x, y)
               }
      return toBool(res);
   }
}
forall a . a : Num => function ge (x : a, y : a) -> Bool {
   return or(Num.gt(x, y), Num.eq(x, y));
}
data uint = uint(word) ;
instance uint : Num {
   function toWord (x : uint) -> word {
      match (x) {
      | uint(y) =>
         return y;
      }
   }

   function fromWord (x : word) -> uint {
      return uint(x);
   }
   function add (x : uint, y : uint) -> uint {
      return uint(addW(Num.toWord(x), Num.toWord(y)));
   }
   function sub (x : uint, y : uint) -> uint {
      return uint(subW(Num.toWord(x), Num.toWord(y)));
   }
   function eq (x : uint, y : uint) -> Bool {
      return Num.eq(Num.toWord(x), Num.toWord(y));
   }
   function gt (x : uint, y : uint) -> Bool {
      return Num.gt(Num.toWord(x), Num.toWord(y));
   }
}
forall abs rep . class  abs : Typedef (rep) {
   function rep (x : abs) -> rep;
   function abs (x : rep) -> abs;
}
instance word : Typedef (word) {
   function rep (x : word) -> word {
      return x;
   }
   function abs (x : word) -> word {
      return x;
   }
}
instance uint : Typedef (word) {
   function rep (x : uint) -> word {
      match (x) {
      | uint(y) =>
         return y;
      }
   }
   function abs (x : word) -> uint {
      return uint(x);
   }
}
data address = address(word) ;
instance address : Typedef (word) {
   function rep (x : address) -> word {
      match (x) {
      | address(y) =>
         return y;
      }
   }
   function abs (x : word) -> address {
      return address(x);
   }
}
data storage (a) = storage(word) ;
data ContractStorage (cxt) = ContractStorage(cxt) ;
data storageRef (a) = storageRef(word) ;
data Proxy (a) = Proxy  ;
data mapping (member, index) = mapping(word, Proxy(member), Proxy(index)) ;
data mapRef (a) = mapRef(word) ;
forall a . instance storage(a) : Typedef (word) {
   function rep (x : storage(a)) -> word {
      match (x) {
      | storage(y) =>
         return y;
      }
   }
   function abs (x : word) -> storage(a) {
      return storage(x);
   }
}
forall a . instance storageRef(a) : Typedef (word) {
   function rep (x : storageRef(a)) -> word {
      match (x) {
      | storageRef(y) =>
         return y;
      }
   }
   function abs (x : word) -> storageRef(a) {
      return storageRef(x);
   }
}
forall lhs rhs . class  lhs : Assign (rhs) {
   function assign (l : lhs, r : rhs) -> ();
}
data ref (a) = ref(a) ;
forall a . instance ref(a) : Assign (a) {
   function assign (l : ref(a), r : a) -> () {
      return ();
   }
}
forall self . class  self : StorageType {
   function sload (ptr : word) -> self;
   function store (ptr : word, value : self) -> ();
}
forall self . class  self : StorageSize {
   function size (x : Proxy(self)) -> word;
}
function sload_ (x : word) -> word {
   let res : word ;
   assembly { res := sload(x)
            }
   return res;
}
function sstore_ (a : word, v : word) {
   assembly { sstore(a, v)
            }
}
instance word : StorageType {
   function sload (ptr : word) -> word {
      let r : word ;
      assembly { r := sload(ptr)
               }
      return r;
   }
   function store (ptr : word, value : word) -> () {
      assembly { sstore(ptr, value)
               }
   }
}
instance uint : StorageType {
   function sload (ptr : word) -> uint {
      return Typedef.abs(sload_(ptr)) : uint;
   }
   function store (ptr : word, value : uint) -> () {
      return sstore_(ptr, Typedef.rep(value));
   }
}
instance address : StorageType {
   function sload (ptr : word) -> address {
      return Typedef.abs(sload_(ptr)) : address;
   }
   function store (ptr : word, value : address) -> () {
      return sstore_(ptr, Typedef.rep(value));
   }
}
forall a . a : StorageType => instance storageRef(a) : Assign (a) {
   function assign (l : storageRef(a), y : a) -> () {
      StorageType.store(Typedef.rep(l), y);
   }
}
forall self fieldType offsetType . class  self : StructField (fieldType, offsetType) {
}
data StructField (structType, fieldSelector) = StructField(structType) ;
data MemberAccessProxy (a, field, offset) = MemberAccessProxy(a, field) ;
forall a field offset . function memberAccessD1 (x : MemberAccessProxy(a, field, offset)) -> a {
   match (x) {
   | MemberAccessProxy(y, z) =>
      return y;
   }
}
forall self memberRefType . class  self : LValueMemberAccess (memberRefType) {
   function memberAccess (x : self) -> memberRefType;
}
forall self memberValueType . class  self : RValueMemberAccess (memberValueType) {
   function memberAccess (x : self) -> memberValueType;
}
forall structType fieldSelector fieldType offsetType . StructField(structType, fieldSelector) : StructField (fieldType, offsetType), offsetType : StorageSize => instance MemberAccessProxy(storage(structType), fieldSelector, offsetType) : LValueMemberAccess (storageRef(fieldType)) {
   function memberAccess (x : MemberAccessProxy(storage(structType), fieldSelector, offsetType)) -> storageRef(fieldType) {
      let ptr : word = Typedef.rep(memberAccessD1(x)) ;
      let size : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      assembly { ptr := add(ptr, size)
               }
      return storageRef(ptr);
   }
}
instance () : StorageSize {
   function size (x : Proxy(())) -> word {
      return 0;
   }
}
instance word : StorageSize {
   function size (x : Proxy(word)) -> word {
      return 1;
   }
}
instance uint : StorageSize {
   function size (x : Proxy(uint)) -> word {
      return 1;
   }
}
instance address : StorageSize {
   function size (x : Proxy(address)) -> word {
      return 1;
   }
}
forall a b . a : StorageSize, b : StorageSize => instance (a, b) : StorageSize {
   function size (x : Proxy((a, b))) -> word {
      let a_sz : word = StorageSize.size(Proxy : Proxy(a)) ;
      let b_sz : word = StorageSize.size(Proxy : Proxy(b)) ;
      assembly { a_sz := add(a_sz, b_sz)
               }
      return a_sz;
   }
}
pragma no-patterson-condition RValueMemberAccess ;
pragma no-coverage-condition MemberAccessProxy, LValueMemberAccess, RValueMemberAccess ;
forall cxt fieldSelector fieldType offsetType . StructField(ContractStorage(cxt), fieldSelector) : StructField (fieldType, offsetType), offsetType : StorageSize => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType) : LValueMemberAccess (storageRef(fieldType)) {
   function memberAccess (x : MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> storageRef(fieldType) {
      let ptr : word = 256 ;
      let offsetSize : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      assembly { ptr := add(ptr, offsetSize)
               }
      return storageRef(ptr);
   }
}
forall cxt fieldSelector fieldType offsetType . StructField(ContractStorage(cxt), fieldSelector) : StructField (fieldType, offsetType), fieldType : StorageType, offsetType : StorageSize => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType) : RValueMemberAccess (fieldType) {
   function memberAccess (x : MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> fieldType {
      let ptr : word = 256 ;
      let offsetSize : word = StorageSize.size(Proxy : Proxy(offsetType)) ;
      return StorageType.sload(addW(ptr, offsetSize)) : fieldType;
   }
}
data mapping (index, member) = mapping(word) ;
forall member index . instance mapping(index, member) : Typedef (word) {
   function rep (x : mapping(index, member)) -> word {
      match (x) {
      | mapping(y) =>
         return y;
      }
   }
   function abs (x : word) -> mapping(index, member) {
      return mapping(x);
   }
}
forall index member . instance mapping(index, member) : StorageSize {
   function size (x : Proxy(mapping(index, member))) -> word {
      return 1;
   }
}
data IndexAccessProxy (map, index, member) = IndexAccessProxy(map, index) ;
forall index member . index : Typedef (word) => instance IndexAccessProxy(storageRef(mapping(index, member)), index, member) : LValueMemberAccess (storageRef(member)) {
   function memberAccess (x : IndexAccessProxy(storageRef(mapping(index, member)), index, member)) -> storageRef(member) {
      return storageRef(indexStorageSlot(x));
   }
}
forall map index member . index : Typedef (word), member : StorageType, map : Typedef (word) => instance IndexAccessProxy(map, index, member) : RValueMemberAccess (member) {
   function memberAccess (x : IndexAccessProxy(map, index, member)) -> member {
      let slot : word = indexStorageSlot(x) ;
      return StorageType.sload(slot);
   }
}
forall index map member . map : Typedef (word), index : Typedef (word) => function indexStorageSlot (x : IndexAccessProxy(map, index, member)) -> word {
   match (x) {
   | IndexAccessProxy(map, i) =>
      let mapptr : word = Typedef.rep(map) ;
      let rawidx : word = Typedef.rep(i) ;
      let loc : word = hash2(mapptr, rawidx) ;
      return loc;
   }
}
forall a b . a : RValueMemberAccess (b) => function rval (x : a) -> b {
   return RValueMemberAccess.memberAccess(x);
}
function caller () -> address {
   let res : word ;
   assembly { res := caller()
            }
   return address(res);
}
function require1fail () {
   let res : word ;
   assembly { mstore(0, 2320231852978620534530211544385868)
              revert(0, 32)
            }
   return ();
}
function require1 (cond : Bool) {
   match (cond) {
   | False =>
      return require1fail();
   | True =>
      return ();
   }
}
function nop () -> () {
   return ();
}
data UintCxt = UintCxt  ;
data reserved_sel = reserved_sel  ;
instance StructField(ContractStorage(UintCxt), reserved_sel) : StructField (word, ()) {
}
data msg_sender_sel = msg_sender_sel  ;
instance StructField(ContractStorage(UintCxt), msg_sender_sel) : StructField (address, (word, ())) {
}
data owner_sel = owner_sel  ;
instance StructField(ContractStorage(UintCxt), owner_sel) : StructField (address, (word, (address, ()))) {
}
data decimals_sel = decimals_sel  ;
instance StructField(ContractStorage(UintCxt), decimals_sel) : StructField (uint, (word, (address, (address, ())))) {
}
data totalSupply_sel = totalSupply_sel  ;
instance StructField(ContractStorage(UintCxt), totalSupply_sel) : StructField (uint, (word, (address, (address, (uint, ()))))) {
}
data balances_sel = balances_sel  ;
instance StructField(ContractStorage(UintCxt), balances_sel) : StructField (mapping(address, uint), (word, (address, (address, (uint, (uint, ())))))) {
}
contract Uint {
   function mint (amount : uint) {
      Assign.assign(LValueMemberAccess.memberAccess(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), rval(MemberAccessProxy(ContractStorage(UintCxt), owner_sel)))), Num.add(rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), rval(MemberAccessProxy(ContractStorage(UintCxt), owner_sel)))), amount));
      Assign.assign(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), totalSupply_sel)), Num.add(rval(MemberAccessProxy(ContractStorage(UintCxt), totalSupply_sel)), amount));
   }
   function transferFrom (src : address, dst : address, amt : uint) -> Bool {
      require1(ge(rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), amt));
      withdraw(src, amt);
      deposit(dst, amt);
      return True;
   }
   function withdraw (src : address, amt : uint) {
      Assign.assign(LValueMemberAccess.memberAccess(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), Num.sub(rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), src)), amt) : uint);
   }
   function deposit (dst : address, amt : uint) {
      Assign.assign(LValueMemberAccess.memberAccess(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), dst)), Num.add(rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), dst)), amt) : uint);
   }
   function init () {
      Assign.assign(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), owner_sel)), address(81985529216486895));
      Assign.assign(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), msg_sender_sel)), caller());
      Assign.assign(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), decimals_sel)), Num.fromWord(18));
   }
   function main () -> uint {
      init();
      mint(uint(1000));
      mint(uint(1000));
      let amt = uint(1) ;
      let src : address = rval(MemberAccessProxy(ContractStorage(UintCxt), owner_sel)) ;
      transferFrom(rval(MemberAccessProxy(ContractStorage(UintCxt), owner_sel)), rval(MemberAccessProxy(ContractStorage(UintCxt), msg_sender_sel)), uint(42));
      require1(True) : ();
      return rval(IndexAccessProxy(LValueMemberAccess.memberAccess(MemberAccessProxy(ContractStorage(UintCxt), balances_sel)), rval(MemberAccessProxy(ContractStorage(UintCxt), msg_sender_sel)))):uint;
   }
}


