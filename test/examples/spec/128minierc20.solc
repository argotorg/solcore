import assign;

function caller() -> address {
  let res: word;
  assembly {
     res := caller()
  }
  return address(res);
}

function myrevert( msg: (word, word) ) -> () {
  match msg {
    | (str, len) =>
       let str1 = str; let len1 = len;
       assembly { mstore(0, str1) revert(0, len1) }
  }
}

function require(cond: bool, msg: (word, word) ) {
      if( not(cond) ) { myrevert(msg); }
}

function require1(cond: bool) {
    require (cond, (0x72657175697265313a204641494c, 14) /* "require1: FAIL" */ );
}

function require2(cond: bool) {
    require(cond, (0x72657175697265323a204641494c, 14) /* "require2: FAIL" */ ); 
}


function nop() -> () { return ();}

contract MiniERC20 {
  reserved : word;
  msg_sender : address; // mock msg.sender
  owner : address;
  decimals : uint;
  totalSupply : uint;
  balances : mapping(address,uint);
  allowance : mapping(address, mapping(address, uint));

  function mint(amount:uint) -> () {
    balances[owner] = Num.add(balances[owner], amount);
    totalSupply = Num.add(totalSupply, amount);
  }

/*  // original:
    function transferFrom(address src, address dst, uint amt) public returns (bool) {
        require(balanceOf[src] >= amt, "token/insufficient-balance");
        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {
            require(allowance[src][msg.sender] >= amt, "token/insufficient-allowance");
            allowance[src][msg.sender] -= amt;
        }

        balanceOf[src] -= amt;
        balanceOf[dst] += amt;
        emit Transfer(src, dst, amt);
        return true;
    }
*/

  function transferFrom(src:address, dst:address, amt:uint) -> bool {
     require (balances[src] >= amt, (0x72657175697265313a204641494c, 14) /* "require1: FAIL" */ ); 

/*
     match (src != msg_sender && allowance[src][msg_sender] != (Num.maxVal():uint)) {
           | true =>
	       require(allowance[src][msg_sender] >= amt, (0x72657175697265323a204641494c, 14) /* "require2: FAIL" */ );
               allowance[src][msg_sender] -= amt;
	   | false => ();
     }
*/
     if (src != msg_sender && allowance[src][msg_sender] != (Num.maxVal():uint)) {
        require(allowance[src][msg_sender] >= amt, (0x72657175697265323a204641494c, 14) /* "require2: FAIL" */ );
        allowance[src][msg_sender] -= amt;
     }
     balances[src] = balances[src] - amt;
     balances[dst] = balances[dst] + amt;
     return true;
  }

/*
    function approve(address usr, uint amt) public returns (bool) {
        allowance[msg.sender][usr] = amt;
        emit Approval(msg.sender, usr, amt);
        return true;
    }
*/

  function approve(usr: address, amt: uint) -> bool {
      allowance[msg_sender][usr] = amt;
      // emit Approval(msg.sender, usr, amt);
      return true;

  }

  function init() -> () {
    owner = address(0x123456789abcdef);
    msg_sender = caller();
    decimals = Num.fromWord(18);
  }

  function main() -> uint {
    init();
    mint(uint(1000));
    allowance[owner][msg_sender] = uint(1000);
    transferFrom(owner, msg_sender, uint(42));

    // return balances[msg_sender] : uint;
    return allowance[owner][msg_sender];
  }
}
