
forall any.function undefined() -> any {
  assembly {
    revert(0,0)
  };
}

function add(x : word, y : word) {
  let res: word;
  assembly {
     res := add(x, y)
  };
  return res;
}

class  ref : Ref(deref) {
  function load (r:ref) -> deref;
  function store(r:ref, v:deref) -> unit;
}

instance stack(a) : Ref(a) {}

data PairFst = PairFst;
data PairSnd = PairSnd;

data Triple(a,b,c)  = Triple(a, b, c);

data Sel3_1 = Sel3_1;
data Sel3_2 = Sel3_2;
data Sel3_3 = Sel3_3;

pragma no-bounded-variable-condition Ref;
data XRef(st, field, fieldType) = XRef(st, field);
instance (r:Ref( (a,b) ) )=>  XRef(r, PairFst, a) : Ref(a) {}
instance (r:Ref( (a,b) ) )=>  XRef(r, PairSnd, b) : Ref(b) {}

pragma no-patterson-condition Ref;
instance (r:Ref( Triple(a,b,c) ) )=>  XRef(r, Sel3_1, a) : Ref(a) {}
instance (r:Ref( Triple(a,b,c) ) )=>  XRef(r, Sel3_2, b) : Ref(b) {}
instance (r:Ref( Triple(a,b,c) ) )=>  XRef(r, Sel3_3, c) : Ref(c) {}


contract AssignPR {
  function fst(p) {
    match p {
      | (a,b) => return a;
    };
  }

  function snd(p) {
    match p {
      | (a,b) => return b;
    };
  }

  function sumPair(p) {
    match p {
      | (a,b) => return add(a,b);
    };
  }

  function sel3_2(t) {
    match t {
      | Triple(a,b,c) => return b;
    };
  }


  function main() {
    let y : stack( Triple(word, word, word) );
    let z : stack( Triple(word, word, word) );

    Ref.store(y, Triple(1,2,3));

    Ref.store( XRef(y, Sel3_2), 21 );
    Ref.store( z, Ref.load(y));

    return Ref.load(XRef(z, Sel3_2));
  }
}