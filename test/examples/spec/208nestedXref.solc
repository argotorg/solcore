
forall any.function revert(a:word,b:word) -> any {
  assembly {
    revert(a,b)
  };
}

function add(x : word, y : word) {
  let res: word;
  assembly {
     res := add(x, y)
  };
  return res;
}

function fst(p) {
  match p {
    | (a,b) => return a;
  };
}

function snd(p) {
  match p {
    | (a,b) => return b;
  };
}

function sumPair(p) {
  match p {
    | (a,b) => return add(a,b);
  };
}


class  ref : Ref(deref) {
  function load (r:ref) -> deref;
  function store(r:ref, v:deref) -> unit;
}

instance stack(a) : Ref(a) {
   // these definitions will not be used
  // function load(r) { return(revert(0,0)); }
  // function store(r, v) { revert(0,0);  }
}

instance stack(a) : Ref(a) {}
data MemberAccess(ty, field) = MemberAccess(ty);

data PairFst = PairFst;
data PairSnd = PairSnd;

// Daniel:
/*
pragma no-coverage-condition Ref;
instance
        (MemberAccess(stack(t), field):Ref(fieldType),
         MemberAccess(stack(fieldType), nestedField):Ref(nestedFieldType)) =>
        MemberAccess(MemberAccess(stack(t), field), nestedField):Ref(nestedFieldType) {}
*/

// Marcin:
pragma no-bounded-variable-condition Ref;
data XRef(st, field, fieldType) = XRef(st, field);
instance (r:Ref( (a,b) ) )=>  XRef(r, PairFst, a) : Ref(a) {}
instance (r:Ref( (a,b) ) )=>  XRef(r, PairSnd, b) : Ref(b) {}

contract AssignNested {
  function main() {
    // let x : (word, (word, word)) = (1, (2,3)) ;
    let x : stack( (word, (word, word)) );
    let z : stack( (word, (word, word)) );
    
    Ref.store(x, (1, (2,3)));
    
    // x.fst = 21
    // let r1 : XRef(stack((word, (word, word))), PairFst, word) = XRef(x,PairFst);
    // let r1 = XRef(x,PairFst);
    // Ref.store(r1, 21);
    // Ref.store(x : XRef,PairFst) : XRef( stack((word, (word, word))), PairFst, word), 21);
    Ref.store( XRef(z,PairFst), 21); 

    // x.snd = (3,4)
    // let r2 : XRef( stack((word, (word, word))), PairSnd, (word, word) ) = XRef(x,PairSnd);
    // Ref.store( r2, (3,4)); 
    // Ref.store( XRef(x,PairSnd) : XRef( stack((word, (word, word))), PairSnd, (word, word)), (3,4)); 

    // x.snd.fst = 42
    /*
    Ref.store(MemberAccess(MemberAccess(x)): MemberAccess
                ( MemberAccess(stack( (word, (word,word)) ), PairSnd)
	        , PairFst
		)
	     , 42);

   */
   // let r21 : XRef(XRef(stack((word, (word, word))), PairSnd, (word, word)), PairFst, word) = XRef(XRef(x, PairSnd), PairFst);
   // Ref.store( r21, 20 );
   // Ref.store( XRef(XRef(x, PairSnd), PairFst), 20 );
   // Ref.store( XRef(XRef(x, PairSnd), PairFst), 20 );

    // let y = x;
    // let y : stack( (word, (word, word)) );
    // Ref.store(y, Ref.load(x));
    // return y.snd.fst

    // return fst(snd(Ref.load(y)));

    return 77;

  }
}