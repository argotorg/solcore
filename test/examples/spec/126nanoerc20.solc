import std;

function caller() -> address {
  let res: word;
  assembly {
     res := caller()
  }
  return address(res);
}

function myrevert( msg: (word, word) ) -> () {
  match msg {
    | (str, len) =>
       let str1 = str; let len1 = len;
       assembly { mstore(0, str1) revert(0, len1) }
  }
}

function require(cond: bool, msg: (word, word) ) {
      if( not(cond) ) { myrevert(msg); }
}

function require1(cond: bool) {
    require (cond, (0x72657175697265313a204641494c, 14) /* "require1: FAIL" */ );
}


function nop() -> () { return ();}

contract Uint {
  reserved : word;
  msg_sender : address; // mock msg.sender
  owner : address;
  decimals : uint256;
  totalSupply : uint256;
  balances : mapping(address,uint256);

  function mint(amount:uint256)  -> () {
    balances[owner] = Num.add(balances[owner], amount);
    totalSupply = Num.add(totalSupply, amount);
  }

  //     function transferFrom(address src, address dst, uint256 amt) public returns (bool)
  function transferFrom(src:address, dst:address, amt:uint256) -> bool {
     require1(ge(balances[src], amt));

     /*
     balances[src] = Num.sub(balances[src], amt);
     balances[dst] = Num.add(balances[dst], amt):uint256;
     */
     withdraw(src, amt); //workaround typechecker quirk
     deposit(dst, amt);
     return true;
  }


  function withdraw(src:address, amt:uint256) -> () {
    balances[src] = Num.sub(balances[src], amt):uint256;
  }

  function deposit(dst:address, amt:uint256) -> () {
    balances[dst] = Num.add(balances[dst], amt):uint256;
  }

  function init() -> () {
    owner = address(0x123456789abcdef);
    msg_sender = caller();
    decimals = uint256(18);
  }

  function main() -> uint256 {
    init();
    mint(uint256(1000));
    let src : address = owner;
    transferFrom(owner, msg_sender, uint256(42));

    return balances[msg_sender] : uint256;
  }
}

