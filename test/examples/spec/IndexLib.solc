import NumLib;

/////// Construction
forall abs rep.
class abs:Typedef(rep) {
    function rep(x:abs) -> rep;
    function abs(x:rep) -> abs;
}


// this does not work :(
/*
forall a
. default instance a:Typedef(a) {
    function rep(x:a) -> word { return a; }
    function abs(x:a) -> word { return a;}
}
*/

instance word:Typedef(word) {
    function rep(x:word) -> word { return x; }
    function abs(x:word) -> word { return x; }
}

instance uint:Typedef(word) {
    function rep(x:uint) -> word {
        match x {
            | uint(y) => return y;
        }
    }
    function abs(x:word) -> uint {
        return uint(x);
    }
}

data address = address(word);

instance address:Typedef(word) {
    function rep(x:address) -> word {
        match x {
            | address(y) => return y;
        }
    }
    function abs(x:word) -> address {
        return address(x);
    }
}

instance address:Eq {
  function eq(x:address, y:address) -> Bool { return Eq.eq(Typedef.rep(x), Typedef.rep(y)); }
}

data storage(a) = storage(word);
data ContractStorage(cxt) = ContractStorage(cxt);

data storageRef(a) = storageRef(word);

data mapping(member, index) = mapping(word, Proxy(member), Proxy(index)); // storage by default
data mapRef(a) = mapRef(word); //ref to a map elem

// data memoryRef(a) = memoryRef(word);

forall a.
instance storage(a):Typedef(word) {
    function rep(x:storage(a)) -> word {
        match x {
            | storage(y) => return y;
        }
    }
    function abs(x:word) -> storage(a) {
        return storage(x);
    }
}

forall a.
instance storageRef(a):Typedef(word) {
    function rep(x:storageRef(a)) -> word {
        match x {
            | storageRef(y) => return y;
        }
    }
    function abs(x:word) -> storageRef(a) {
        return storageRef(x);
    }
}

forall lhs rhs.
class lhs:Assign(rhs) {
    function assign(l:lhs, r:rhs) -> ();
}

data ref(a) = ref(a);

forall a.
instance ref(a):Assign(a) {
    function assign(l:ref(a), r:a) -> () {
        // builtin "stack store"
        return ();
    }
}

forall self.
class self:StorageType {
    function sload(ptr:word) -> self;
    function store(ptr:word, value:self) -> ();
}

forall self.
class self:StorageSize {
    function size(x:Proxy(self)) -> word;
}


function sload_(x:word) -> word {
    let res: word;
    assembly {
       res := sload(x)
    }
    return res;
  }

function sstore_(a:word, v:word) {
    assembly { sstore(a,v) }
}

instance word:StorageType {
    function sload(ptr:word) -> word {
        let r:word;
        assembly {
            r := sload(ptr);
        }
        return r;
    }
    function store(ptr:word, value:word) -> () {
        assembly {
            sstore(ptr, value)
        }
    }
}

instance uint:StorageType {
    function sload(ptr:word) -> uint {
        return Typedef.abs(sload_(ptr)):uint; // type annotation needed due to a typechecker bug
    }
    function store(ptr:word, value:uint) -> () {
        return sstore_(ptr, Typedef.rep(value));
    }
}

instance address:StorageType {
    function sload(ptr:word) -> address {
        return Typedef.abs(sload_(ptr)):address; // type annotation needed due to a typechecker bug
    }
    function store(ptr:word, value:address) -> () {
        return sstore_(ptr, Typedef.rep(value));
    }
}

forall a . a : StorageType => instance storageRef(a):Assign(a) {
    function assign(l:storageRef(a), y:a) -> () {
        StorageType.store(Typedef.rep(l), y);
    }
}

forall self fieldType offsetType.
class self:StructField(fieldType, offsetType) {}
data StructField(structType, fieldSelector) = StructField(structType);


data MemberAccessProxy(a, field, offset) = MemberAccessProxy(a, field);

forall a field offset .
function memberAccessD1(x:MemberAccessProxy(a, field, offset)) -> a {
    match x {
        | MemberAccessProxy(y,z) => return y;
    }
}

forall self memberRefType.
class self:LValueMemberAccess(memberRefType) {
    function memberAccess(x:self) -> memberRefType;
}

forall self memberValueType .
class self:RValueMemberAccess(memberValueType) {
    function memberAccess(x:self) -> memberValueType;
}

forall structType fieldSelector fieldType offsetType
  . StructField(structType, fieldSelector):StructField(fieldType, offsetType)
  , offsetType:StorageSize
  => instance MemberAccessProxy(storage(structType), fieldSelector, offsetType):LValueMemberAccess(storageRef(fieldType)) {
    function memberAccess(x:MemberAccessProxy(storage(structType), fieldSelector, offsetType)) -> storageRef(fieldType) {
        let ptr:word = Typedef.rep(memberAccessD1(x));
        let size:word = StorageSize.size(Proxy:Proxy(offsetType));
        assembly {
            ptr := add(ptr, size)
        }
        return storageRef(ptr);
    }
}

instance ():StorageSize {
    function size(x:Proxy(())) -> word {
        return 0;
    }
}

instance word:StorageSize {
    function size(x:Proxy(word)) -> word {
        return 1;
    }
}

instance uint:StorageSize {
    function size(x:Proxy(uint)) -> word {
        return 1;
    }
}

instance address:StorageSize {
    function size(x:Proxy(address)) -> word {
        return 1;
    }
}


/*
// fails Patterson cond
forall a b . a:Typedef(b), b:StorageSize
=> instance a:StorageSize {
    function size(x:Proxy(a)) -> word {
        return StorageSize.size(Proxy(b));
    }
}
*/

forall a b . a:StorageSize, b:StorageSize => instance (a,b):StorageSize {
    function size(x:Proxy((a,b))) -> word {
        let a_sz:word = StorageSize.size(Proxy:Proxy(a));
        let b_sz:word = StorageSize.size(Proxy:Proxy(b));
        assembly {
            a_sz := add(a_sz, b_sz)
        }
        return a_sz;
    }
}

pragma no-patterson-condition RValueMemberAccess; // this is due to ContractStorage(cxt); probably not needed once we have local instances
pragma no-coverage-condition MemberAccessProxy, LValueMemberAccess, RValueMemberAccess;

// ------------------------------------------------------------------
// Contract field access
// ------------------------------------------------------------------

forall cxt fieldSelector fieldType offsetType
  . StructField(ContractStorage(cxt), fieldSelector):StructField(fieldType, offsetType)
  , offsetType:StorageSize
  => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType):LValueMemberAccess(storageRef(fieldType)) {
    function memberAccess(x:MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> storageRef(fieldType) {
        let ptr:word = 0x100; // forge uses at least 1 storage slot
        let offsetSize:word = StorageSize.size(Proxy:Proxy(offsetType));

        assembly {
            ptr := add(ptr, offsetSize)
        }
        return storageRef(ptr); // contract storage starts at 0
    }
}

forall cxt fieldSelector fieldType offsetType
  . StructField(ContractStorage(cxt), fieldSelector):StructField(fieldType, offsetType)
  , fieldType:StorageType
  , offsetType:StorageSize
  => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType):RValueMemberAccess(fieldType) {
    function memberAccess(x:MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> fieldType {
        let ptr:word = 0x100;
        let offsetSize:word = StorageSize.size(Proxy:Proxy(offsetType));
        return StorageType.sload(addW(ptr, offsetSize)):fieldType;
    }
}

/*
forall cxt fieldSelector fieldType offsetType
  . StructField(ContractStorage(cxt), fieldSelector):StructField(fieldType, offsetType)
  , fieldType:StorageType
  , offsetType:StorageSize
  => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType):RValueMemberAccess(fieldType) {
    function memberAccess(x:MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> fieldType {
        let ptr:word = 0x100;
        let offsetSize:word = StorageSize.size(Proxy:Proxy(offsetType));
        return StorageType.sload(addW(ptr, offsetSize)):fieldType;
    }
}
*/
// ------------------------------------------------------------------
// Indexed access
// ------------------------------------------------------------------

data mapping(index, member) = mapping(word);

forall member index . instance mapping(index, member):Typedef(word) {
    function rep(x:mapping(index, member)) -> word {
        match x {
            | mapping(y) => return y;
        }
    }
    function abs(x:word) -> mapping(index,member) {
        return mapping(x);
    }
}


// cf https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#mappings-and-dynamic-arrays
forall index member .
instance mapping(index, member):StorageSize {
    function size(x:Proxy(mapping(index, member))) -> word {
        return 1;
    }
}

data IndexAccessProxy(map, index, member) = IndexAccessProxy(map, index);

forall index member. index:Typedef(word)
=> instance IndexAccessProxy(storageRef(mapping(index,member)), index, member):LValueMemberAccess(storageRef(member)) {
    function memberAccess(x:IndexAccessProxy(storageRef(mapping(index,member)), index, member)) -> storageRef(member) {
	    return storageRef(indexStorageSlot(x));
    }
}

forall map index member . index:Typedef(word), member:StorageType, map:Typedef(word)
=> instance IndexAccessProxy(map, index, member):RValueMemberAccess(member) {
    function memberAccess(x:IndexAccessProxy(map, index, member)) -> member {
            let slot:word = indexStorageSlot(x);
	    return StorageType.sload(slot);
    }
}

forall index map member. map:Typedef(word), index:Typedef(word) => function indexStorageSlot(x:IndexAccessProxy(map, index, member)) -> word
//function indexStorageSlot(x)
{
	match x {
	    | IndexAccessProxy(map, i) =>
	    	    let mapptr:word = Typedef.rep(map);
                    let rawidx:word = Typedef.rep(i);
		    let loc:word = hash2(mapptr, rawidx);
		    return loc;
        }
}

/*
forall index map member. map:Typedef(word), index:Typedef(word)
=> function indexedSlot(mapref : storageRef(mapping(index, member)), i: index) -> word
{
	match mapref {
	    | storageRef(mapptr) =>
                    let rawidx:word = Typedef.rep(i);
		    let loc:word = hash2(mapptr, rawidx);
		    return loc;
        }
}
*/

forall a b. a:RValueMemberAccess(b) =>
function rval(x:a) -> b {
  return RValueMemberAccess.memberAccess(x);
}
