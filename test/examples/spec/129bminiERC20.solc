import dispatch;

function caller() -> address {
  let res: word;
  assembly {
     res := caller()
  }
  return address(res);
}

function myrevert(msg: word) -> () {
       assembly { mstore(0, msg) revert(0, 32) }
}

function require(cond: bool, msg: word ) {
      if( !cond ) { myrevert(msg); }
}

// function make_short_mstring(len:word, payload:word)

contract MiniERC20 {
  reserved : word; // forge idiosyncrasies
  name : mstring;
  symbol : mstring;
  owner : address;
  decimals : uint256;
  totalSupply : uint256;
  balances : mapping(address,uint256);
  allowance : mapping(address, mapping(address, uint256));


  constructor(name_ : mstring, symbol_ : mstring, totalSupply_ : uint256) {
    name = name_;
    symbol = symbol_;
    owner = caller();
    decimals = uint256(18);
    owner = caller();
    mint(totalSupply_);
  }

  function getName() -> mstring {
    return name;
  }

  function getSymbol() -> mstring {
    return symbol;
  }
  
  function getOwner() -> address {
    return owner;
  }
  
  function getTotalSupply() -> uint256 {
    return totalSupply;
  }
  function mint(amount:uint256) -> () {
    balances[owner] = Num.add(balances[owner], amount);
    totalSupply = Num.add(totalSupply, amount);
  }

  function transferFrom(src:address, dst:address, amt:uint256) -> uint256 {
     let msg_sender = caller();
     require( balances[src] >= amt /* "token/insufficient-balance" */
            , 0x746f6b656e2f696e73756666696369656e742d62616c616e6365
	    );

     if (src != msg_sender && allowance[src][msg_sender] != (Num.maxVal():uint256)) {
        require( allowance[src][msg_sender] >= amt /* "token/insufficient-allowance" */
	       , 0x746f6b656e2f696e73756666696369656e742d616c6c6f77616e6365
	       );
        allowance[src][msg_sender] -= amt;
     }
     balances[src] = balances[src] - amt;
     balances[dst] = balances[dst] + amt;
     // return true;
     return uint256(1);
  }

/*
    function approve(address usr, uint256 amt) public returns (bool) {
        allowance[msg.sender][usr] = amt;
        emit Approval(msg.sender, usr, amt);
        return true;
    }
*/

  function approve(usr: address, amt: uint256) -> uint256 {
      let msg_sender = caller();
      allowance[msg_sender][usr] = amt;
      // emit Approval(msg.sender, usr, amt);
      // return true;
      return uint256(1);
  }
/*
  function init() -> () {
    owner = address(0x123456789abcdef);
    decimals = Num.fromWord(18) : uint256;
  }
  function main() -> uint256 {
    let msg_sender = caller();
    init();
    mint(uint256(1000));
    allowance[owner][msg_sender] = uint256(1000);
    transferFrom(owner, msg_sender, uint256(42));

    return allowance[owner][msg_sender];
  }
*/
}
