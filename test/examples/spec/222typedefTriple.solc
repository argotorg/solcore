class  ref : Ref(deref) {
  function load (r:ref) -> deref;
  function store(r:ref, v:deref) -> unit;
}

data stack(a) = stack(a);
instance stack(a) : Ref(a) {}

data PairFst = PairFst;
data PairSnd = PairSnd;
data Rep = Rep;

class self:Typedef(underlyingType) {
    function rep(x:self) -> underlyingType;
    function abs(x:underlyingType) -> self;
}

pragma no-coverage-condition Typedef;
instance (a:Typedef(b)) => stack(a):Typedef(stack(b)) {} // should be autogenerated

data Triple(a,b,c)  = Triple(a, b, c);
instance Triple(a,b,c):Typedef( (a,b,c) ) {}

pragma no-bounded-variable-condition Ref;
data XRef(st, field, fieldType) = XRef(st, field);
instance (r:Ref( (a,b) ) )=>  XRef(r, PairFst, a) : Ref(a) {} // should be autogenerated
instance (r:Ref( (a,b) ) )=>  XRef(r, PairSnd, b) : Ref(b) {} // should be autogenerated

/* if we have a reference to s and know that it is represented by u
   we can treat it as a reference to u */
instance (r:Ref(s), s:Typedef(u))=> XRef(r, Rep, u) : Ref(u) {}

contract TypedefTriple {

  function main() -> word {
    let y : stack( Triple(word, word, word) );
    let z : stack( Triple(word, word, word) );

    // y = Triple(1,2,3)
    Ref.store(y, Triple(1,2,3));

    // y.1 = 20
    Ref.store( XRef(XRef(y, Rep), PairFst), 20 );

    // y.2 = 21

    Ref.store( XRef(XRef(XRef(y, Rep), PairSnd), PairFst), 21 );
    Ref.store( z, Ref.load(y));

    // return z.2
    return Ref.load(XRef(XRef(XRef(z, Rep), PairSnd), PairFst));
  }
}