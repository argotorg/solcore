/*
# Types and classes for assignemnt desugaring
- access proxy types
- LValue and RValue access classes (LVA, RVA)
- Assign class
*/


// Would import std if it weren't for pragmas :(
// import std;

// -- relevant fragments of std
import types;
import NumLib;

// -- std ends


pragma no-patterson-condition RVA;
pragma no-coverage-condition MemberAccessProxy, LVA, RVA, StructField;

// -- storage

function sload_(x:word) -> word {
    let res: word;
    assembly {
       res := sload(x)
    }
    return res;
  }

function sstore_(a:word, v:word) {
    assembly { sstore(a,v) }
}


forall self.
class self:StorageSize {
    function size(x:Proxy(self)) -> word;
}

instance ():StorageSize {
    function size(x:Proxy(())) -> word {
        return 0;
    }
}

instance word:StorageSize {
    function size(x:Proxy(word)) -> word {
        return 1;
    }
}

instance uint:StorageSize {
    function size(x:Proxy(uint)) -> word {
        return 1;
    }
}

instance address:StorageSize {
    function size(x:Proxy(address)) -> word {
        return 1;
    }
}

forall a b . a:StorageSize, b:StorageSize => instance (a,b):StorageSize {
    function size(x:Proxy((a,b))) -> word {
        let a_sz:word = StorageSize.size(Proxy:Proxy(a));
        let b_sz:word = StorageSize.size(Proxy:Proxy(b));
        assembly {
            a_sz := add(a_sz, b_sz)
        }
        return a_sz;
    }
}


forall self.
class self:StorageType {
    function sload(ptr:word) -> self;
    function store(ptr:word, value:self) -> ();
}

instance word:StorageType {
    function sload(ptr:word) -> word {
        let r:word;
        assembly {
            r := sload(ptr);
        }
        return r;
    }
    function store(ptr:word, value:word) -> () {
        assembly {
            sstore(ptr, value)
        }
    }
}

instance address:StorageType {
    function sload(ptr:word) -> address {
        return Typedef.abs(sload_(ptr)):address; // type annotation needed due to a typechecker bug
    }
    function store(ptr:word, value:address) -> () {
        return sstore_(ptr, Typedef.rep(value));
    }
}


forall a. a:Typedef(word) =>
function sloadViaWord(ptr:word) -> a {
    let r:word;
    assembly {
	r := sload(ptr);
    }
    return Typedef.abs(r);
}

forall a. a:Typedef(word) =>
function storeViaWord(ptr:word, value:a) -> () {
    let w: word = Typedef.rep(value);
    assembly {
	sstore(ptr, w)
    }
}

instance uint:StorageType {
  function sload(ptr:word) -> uint { return uint(StorageType.sload(ptr):word); }
  function store(ptr:word, value:uint) -> () { StorageType.store(ptr, Typedef.rep(value):word); }
}


// -- structure fields (including contract fields)

 forall self fieldType offsetType.
class self:StructField(fieldType, offsetType) {}
data StructField(structType, fieldSelector) = StructField(structType);


data MemberAccessProxy(a, field, offset) = MemberAccessProxy(a, field);

forall a field offset .
function memberAccessBase(x:MemberAccessProxy(a, field, offset)) -> a {
    match x {
        | MemberAccessProxy(y,z) => return y;
    }
}


// ------------------------------------------------------------------
// Contract field access
// ------------------------------------------------------------------

forall cxt fieldSelector fieldType offsetType
  . StructField(ContractStorage(cxt), fieldSelector):StructField(fieldType, offsetType)
  , offsetType:StorageSize
  => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType):LVA(storage(fieldType)) {
    function acc(x:MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> storage(fieldType) {
        let ptr:word = 0x100; // forge uses at least 1 storage slot
        let offsetSize:word = StorageSize.size(Proxy:Proxy(offsetType));

        assembly {
            ptr := add(ptr, offsetSize)
        }
        return storage(ptr); 
    }
}

forall cxt fieldSelector fieldType offsetType
  . StructField(ContractStorage(cxt), fieldSelector):StructField(fieldType, offsetType)
  , fieldType:StorageType
  , offsetType:StorageSize
  => instance MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType):RVA(fieldType) {
    function acc(x:MemberAccessProxy(ContractStorage(cxt), fieldSelector, offsetType)) -> fieldType {
        let ptr:word = 0x100;
        let offsetSize:word = StorageSize.size(Proxy:Proxy(offsetType));
        return StorageType.sload(addW(ptr, offsetSize)):fieldType;
    }
}


forall structType fieldSelector fieldType offsetType
  . StructField(structType, fieldSelector):StructField(fieldType, offsetType)
  , offsetType:StorageSize
  => instance MemberAccessProxy(storage(structType), fieldSelector, offsetType):LVA(storage(fieldType)) {
    function acc(x:MemberAccessProxy(storage(structType), fieldSelector, offsetType)) -> storage(fieldType) {
        let ptr:word = Typedef.rep(memberAccessBase(x));
        let size:word = StorageSize.size(Proxy:Proxy(offsetType));
        assembly {
            ptr := add(ptr, size)
        }
        return storage(ptr);
    }
}


forall structType fieldSelector fieldType offsetType
  . StructField(structType, fieldSelector):StructField(fieldType, offsetType)
  , offsetType:StorageSize
  , fieldType:StorageType
  => instance MemberAccessProxy(storage(structType), fieldSelector, offsetType):RVA(fieldType) {
    function acc(x:MemberAccessProxy(storage(structType), fieldSelector, offsetType)) -> fieldType {
        let ptr:word = Typedef.rep(memberAccessBase(x));
        let size:word = StorageSize.size(Proxy:Proxy(offsetType));
        assembly {
            ptr := add(ptr, size)
        }
        return StorageType.sload(ptr);
    }
}




data ContractStorage(cxt) = ContractStorage(cxt);


forall member index . instance mapping(index, member):Typedef(word) {
    function rep(x:mapping(index, member)) -> word {
        match x {
            | mapping(y) => return y;
        }
    }
    function abs(x:word) -> mapping(index,member) {
        return mapping(x);
    }
}


// cf https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#mappings-and-dynamic-arrays
forall index member .
instance mapping(index, member):StorageSize {
    function size(x:Proxy(mapping(index, member))) -> word {
        return 1;
    }
}

forall self memberRefType.
class self:LVA(memberRefType) {
    function acc(x:self) -> memberRefType;
}


forall self member.
class self:RVA(member) {
    function acc(x:self) -> member;
}

forall a b. a:RVA(b) =>
function rval(x:a) -> b {
  return RVA.acc(x);
}


forall lhs rhs.
class lhs:Assign(rhs) {
    function assign(l:lhs, r:rhs) -> ();
}


forall a. a:StorageType =>
instance storage(a):Assign(a) {
    function assign(l:storage(a), r:a) -> () {
      StorageType.store(Typedef.rep(l), r);
    }
}

// -- Tuple-based indexed access:

forall col_idx val . class col_idx:RValueIdxAccess(val) {
  function lookup(ci : col_idx) -> val;
}

forall col_idx ref . class col_idx:LValueIdxAccess(ref) {
  function lookup(ci : col_idx) -> ref;
}

forall i a . i:Typedef(word) =>
instance (storage(mapping(i,a)), i): LValueIdxAccess(storage(a)) {
  function lookup(xi : (storage(mapping(i,a)), i)) -> storage(a) {
    match(xi) {
      | (x, i) => return storage(hash2(Typedef.rep(x), Typedef.rep(i)));
    }
   
    // return storage(42); // FIXME: hash2(x,i);
  }
}

forall i a . a:StorageType, i:Typedef(word) =>
instance (storage(mapping(i,a)), i): RValueIdxAccess(a) {
  function lookup(xi : (storage(mapping(i,a)), i)) -> a {
  /*
    match(xi) {
      | (x, i) => return StorageType.sload(hash2(Typedef.rep(x), Typedef.rep(i)));
    }
  */
  return readStorage(LValueIdxAccess.lookup(xi));
  }
}

forall a. a:StorageType =>
function readStorage(x:storage(a)) -> a {
  return StorageType.sload(Typedef.rep(x));
}
/*
forall r a. a:StorageType, r: RValueIdxAccess(a) =>
function rval(x:r) -> a {
  return RValueIdxAccess.lookup(x);
}

forall r a. r: LValueIdxAccess(a) =>
function lval(x:r) -> a {
  return LValueIdxAccess.lookup(x);
}
*/

forall i a . i:Typedef(word) =>
function lidx( m: storage(mapping(i,a)), x:i) -> storage(a) {
  return storage(hash2(Typedef.rep(m), Typedef.rep(x)));
}

forall i a . i:Typedef(word), a:StorageType  =>
function ridx( m: storage(mapping(i,a)), x:i) -> a {
  return StorageType.sload(hash2(Typedef.rep(m), Typedef.rep(x)));
}

