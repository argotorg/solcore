import std;

pragma no-patterson-condition RunDispatch, ExecMethod;

// --- Core Data Types ---

// A contract contains a tuple of methods and a single fallback
// TODO: implement receive()
data Contract(methods, fallback) = Contract(methods,fallback);

// A method contains an implementation (fn) as well as it's name and type signature
data Method(name, payability, args, rets, fn) = Method(Proxy(name), Proxy(payability), Proxy(args), Proxy(rets), fn);

// Contains the implementation for the fallback (fn) as well as it's type signature
data Fallback(payability, args, rets, fn) = Fallback(Proxy(payability), Proxy(args), Proxy(rets), fn);

// --- Method Selectors ---

// The string representation of abi types used during selector computation
forall ty . class ty:ABIString {
    function append(head : word, tail : word, prx : Proxy(ty)) -> word;
}

instance uint256:ABIString {
    function append(head : word, tail : word, prx : Proxy(uint256)) -> word {
        let size : word = 7;
        assembly {
            mstore(head, add(mload(head), size))
            mstore(tail, 0x75696e7432353600000000000000000000000000000000000000000000000000)
        }
        return Add.add(tail, size);
    }
}

instance ():ABIString {
    function append(head : word, tail : word, prx : Proxy(())) -> word {
        return(tail);
    }
}

function append_left_bracket(head : word, tail : word) -> word {
    let size = 1;
    assembly {
        mstore(head, add(mload(head), size));
        mstore(tail, 0x2800000000000000000000000000000000000000000000000000000000000000);
    }
    return Add.add(tail, size);
}

function append_right_bracket(head : word, tail : word) -> word {
    let size = 1;
    assembly {
        mstore(head, add(mload(head), size));
        mstore(tail, 0x2900000000000000000000000000000000000000000000000000000000000000);
    }
    return Add.add(tail, size);
}

function append_comma(head : word, tail : word) -> word {
    let size = 1;
    assembly {
        mstore(head, add(mload(head), size));
        mstore(tail, 0x2c00000000000000000000000000000000000000000000000000000000000000);
    }
    return Add.add(tail, size);
}

forall l r . l:ABIString, r:ABIString => instance (l,r):ABIString {
    function append(head : word, tail : word, prx : Proxy((l,r))) -> word {
        let with_l = ABIString.append(head, tail, Proxy : Proxy(l));
        let with_comma = append_comma(head, with_l);
        return ABIString.append(head, with_comma, Proxy : Proxy(r));
    }
}

forall ty . class ty:Selector {
    function compute(prx : Proxy(ty)) -> bytes4;
}

// Computes the selector hash for a given method
// this is a class with a single instance since it made some of the downstream definitions a bit cleaner to define
// NOTE: for efficiency purposes this leaves dirty data past the end of the free memory pointer
forall name payability args rets fn
    . name:ABIString
    , args:ABIString
=> instance Method(name,payability,args,rets,fn):Selector {
    function compute(prx : Proxy(Method(name,payability,args,rets,fn))) -> bytes4 {
        // setup memory pointers for the selector string
        let head = get_free_memory();
        let tail = Add.add(head, 32);

        // ensure the size is zero
        assembly { mstore(head, 0) }

        // write the selector string
        tail = ABIString.append(head, tail, Proxy : Proxy(name));
        tail = append_left_bracket(head, tail);
        tail = ABIString.append(head, tail, Proxy : Proxy(args));
        tail = append_right_bracket(head, tail);

        // hash it & get the first four bytes
        let res : word;
        assembly {
            let hash := keccak256(add(head, 32), mload(head))
            res := shr(224, hash)
        }
        return bytes4(res);
    }
}

// --- Method Execution ---

// Describes how to execute a given method / fallback
forall ty . class ty:ExecMethod {
  function exec(x: ty);
}

// If fn matches the provided args/ret types, then we can execute any method
forall name payability args rets fn
  . fn:invokable(args,rets)
  , args:ABIAttribs
  , rets:ABIAttribs
  , ABIDecoder(args,CalldataWordReader):ABIDecode(args)
  , rets:ABIEncode
  , payability:MethodLevelCallvalueCheck
=> instance Method(name,payability,args,rets,fn):ExecMethod {
  function exec(m : Method(name,payability,args,rets,fn)) -> () {
    match m {
      | Method(pnm,ppayability,pargs,prets,fn) =>
        do_exec(ppayability, pargs, prets, fn);
    }
  }
}

// If fn matches the provided args/ret types, then we can execute any fallback
forall payability args rets fn
  . fn:invokable(args,rets)
  , args:ABIAttribs
  , rets:ABIAttribs
  , ABIDecoder(args,CalldataWordReader):ABIDecode(args)
  , rets:ABIEncode
  , payability:MethodLevelCallvalueCheck
=> instance Fallback(payability,args,rets,fn):ExecMethod {
  function exec(fb : Fallback(payability,args,rets,fn)) -> () {
    match fb {
      | Fallback(ppayability, pargs, prets, fn) =>
        do_exec(ppayability, pargs, prets, fn);
    }
  }
}

forall payability args rets fn
  . fn:invokable(args,rets)
  , args:ABIAttribs
  , rets:ABIAttribs
  , ABIDecoder(args,CalldataWordReader):ABIDecode(args)
  , rets:ABIEncode
  , payability:MethodLevelCallvalueCheck
=> function do_exec(ppayability : Proxy(payability), pargs : Proxy(args), prets : Proxy(rets), fn : fn) -> () {
    // check callvalue
    MethodLevelCallvalueCheck.checkCallvalue(Proxy : Proxy(payability));

    // check we have enough calldata for the head of args
    let hdsz = ABIAttribs.headSize(pargs);
    assembly {
        if lt(sub(calldatasize(), 4), hdsz) {
            revert(0,0);
        };
    }

    // TODO: calldatasize checks for dynamic types

    // abi decode args from calldata
    let ptr : calldata(bytes) = calldata(4);

    // TODO: this needs entirely too many type annotations
    let args : args = abi_decode(ptr, pargs, Proxy : Proxy(CalldataWordReader));

    // call fn with args
    // TODO: why are type annotations needed here?
    let rets : rets = fn(args);

    // abi encode rets to memory
    let ptr = abi_encode(rets);

    // TODO: this is broken for dynamically sized types...
    let retSz : word = ABIAttribs.headSize(prets);
    let start : word = Typedef.rep(ptr);

    assembly {
        return(start,retSz)
    }
}

// --- Method Dispatch ---

// For a given tuple of methods this executes the method specified by the first four bytes of calldata
forall ty . class ty:RunDispatch {
  function go(methods : ty) -> ();
}

// We can dispatch to a single executable method with a known selector
forall name payability args rets fn
  . Method(name,payability,args,rets,fn):ExecMethod
  , Method(name,payability,args,rets,fn):Selector
=> instance Method(name,payability,args,rets,fn):RunDispatch {
  function go(method : Method(name,payability,args,rets,fn)) -> () {
    match selector_matches(Proxy : Proxy(Method(name,payability,args,rets,fn))) {
      | true => ExecMethod.exec(method);
      | false => return ();
    }
  }
}

// Recursive instance
forall n m . n:ExecMethod, n:Selector, m:RunDispatch => instance (n,m):RunDispatch {
  function go(methods : (n,m)) -> () {
    match methods {
      | (method_n, rest) =>
        match selector_matches(Proxy : Proxy(n)) {
          | true => ExecMethod.exec(method_n);
          | false => RunDispatch.go(rest);
        }
    }
  }
}

// TODO: we only wanna do the calldataload once
// Given evidence of a type with a known selector, we can check if it matches the selector in the first four bytes of calldata
forall ty . ty:Selector => function selector_matches(prx : Proxy(ty)) -> bool {
  let candidate = Typedef.rep(Selector.compute(prx));
  let res : word;
  assembly {
    let sel := shr(224, calldataload(0));
    res := eq(sel, candidate);
  }
  match res {
    | 0 => return false;
    | _ => return true;
  }
}

// --- Callvalue Checks ---

data Payable;
data NonPayable;

forall ty . class ty:MethodLevelCallvalueCheck {
    function checkCallvalue(pty : Proxy(ty));
}

// no callvalue check for Payable methods
instance Payable:MethodLevelCallvalueCheck {
    function checkCallvalue(prx : Proxy(Payable)) -> () { }
}
// NonPayable methods revert if passed value
instance NonPayable:MethodLevelCallvalueCheck {
   function checkCallvalue(prx : Proxy(NonPayable)) -> () {
       assembly {
         if gt(callvalue(), 0) {
           mstore(0, 0x1);
           revert(0, 32);
         }
       }
   }
}

// --- Contract Execution ---

// Describes how to execute a given contract
forall c . class c:RunContract {
  function exec(v : c) -> ();
}

// If we have a dispatch for the contracts methods, and we know how to execute it's fallback, then we can define an entrypoint
forall methods fallback . methods:RunDispatch, fallback:ExecMethod => instance Contract(methods, fallback):RunContract {
  function exec(c : Contract(methods, fallback)) -> () {
    match c {
      | Contract(ms, fb) =>

        // TODO: if all methods are non payable then we should life the callvalue check here

        // check that we have at least 4 bytes of calldata
        let haveSelector : word;
        assembly {
          haveSelector := lt(3, calldatasize());
        }

        match haveSelector {
          | 0 =>
              assembly {
                  mstore(0,0xff)
                  revert(0,1)
              }
          | _ =>
            // set free memory pointer to the output of memoryguard
            // https://docs.soliditylang.org/en/v0.8.30/yul.html#memoryguard
            // TODO: we will need to consider immutables here at some point...
            assembly { mstore(0x40, memoryguard(128)); }

            // dispatch to method based on selector
            RunDispatch.go(ms);
            // run fallback if no methods matched
            ExecMethod.exec(fb);
        }
    }
  }
}

// --- Manually Desugared Example ---

// compiler generated

function revert_handler() -> () {
  assembly { revert(0,0) }
}

data C_Add2_Name;

instance C_Add2_Name:ABIString {
    function append(head : word, tail : word, prx : Proxy(C_Add2_Name)) -> word {
        let size = 4;
        assembly {
            mstore(head, add(mload(head), size));
            mstore(tail, 0x6164643200000000000000000000000000000000000000000000000000000000);
        }
        return Add.add(tail, size);
    }
}

// transform

contract C {
  function add2(x : uint256, y : uint256) -> uint256 {
    return Add.add(x,y);
  }

  function main() -> () {
    let c = Contract(
      Method(Proxy: Proxy(C_Add2_Name), Proxy : Proxy(NonPayable), Proxy : Proxy((uint256,uint256)), Proxy : Proxy(uint256), add2),
      Fallback(Proxy : Proxy(NonPayable), Proxy : Proxy(()), Proxy : Proxy(()), revert_handler)
    );

    RunContract.exec(c);
  }
}
