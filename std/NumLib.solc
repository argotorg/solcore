import types;
function addW(x : word, y : word) {
  let res: word;
  assembly {
     res := add(x, y)
  }
  return res;
}

function subW(x : word, y : word) {
  let res: word;
  assembly {
     res := sub(x, y)
  }
  return res;
}

function addU(x : uint, y : uint) -> uint {
  let res: word;
  let xw : word = Num.toWord(x);
  let yw : word = Num.toWord(y);
  assembly {
     res := add(xw, yw)
  }
  return uint(res);
}

function hash1(x: word) -> word {
  let result: word = 0;
  assembly {
    mstore(0, x)
    result := keccak256(0,32)
  }
  return result;
}

function hash2(x: word, y: word) -> word {
  let result: word = 0;
  assembly {
    mstore(0, x)
    mstore(32, y)
    result := keccak256(0,64)
  }
  return result;
}

// data Bool = False | True;

function not(b:bool) -> bool {
  match b {
    | false => return true;
    | true => return false;
  }
}

function or(x:bool, y:bool) -> bool {
  match x {
    | false => return y;
    | true => return true;
  }
}

function and(x:bool, y:bool) -> bool {
  match x {
    | false => return false;
    | true => return y;
  }
}

function frombool(b) {
 match b {
   | false => return 0;
   | true => return 1;
 }
}

function tobool(x: word) {
  match x {
    | 0 => return false;
    | _ => return true;
  }
}

forall a.
class a:Eq {
  function eq(x:a, y:a) -> bool;
}

instance word:Eq {
  function eq(x:word, y:word) -> bool {
    let res : word;
    assembly {
       res := eq(x, y)
    }
    return tobool(res);
  }
}

forall a. a:Eq =>
function ne(x:a, y:a) {
  return not(Eq.eq(x,y));
}

forall a. a:Eq =>
class a:Num {
  function maxVal() -> a;
  function toWord(x:a) -> word;
  function fromWord(x:word) -> a;
  function add(x:a, y:a) -> a;
  function sub(x:a, y:a) -> a;
  function gt(x:a, y:a) -> bool;
}

instance word:Num {
  function maxVal() -> word {
    return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
  }
  function toWord(x:word) -> word { return x; }
  function fromWord(x:word) -> word { return x; }

  function add(x:word, y:word) -> word { return addW(x, y); }
  function sub(x:word, y:word) -> word { return addW(x, y); }
  function gt(x:word, y:word) -> bool {
    let res : word;
    assembly {
       res := gt(x, y)
    }
    return tobool(res);
  }
}

forall a. a:Num =>
function ge(x:a, y:a) -> bool {
  return or(Num.gt(x,y), Eq.eq(x,y));
}


instance uint:Eq {
  function eq(x:uint, y:uint) -> bool { return Eq.eq(Num.toWord(x), Num.toWord(y)); }
}

instance address:Eq {
  function eq(x : address , y : address) -> bool {
    return Eq.eq(Typedef.rep(x), Typedef.rep(y));
  }
}

instance uint:Num {
  function maxVal() -> uint {
    return uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  }
  function toWord(x:uint) -> word
  {
          match x {
            | uint(y) => return y;
        }
  }
  function fromWord(x:word) -> uint { return uint(x); }
  function add(x:uint, y:uint) -> uint { return uint(addW(Num.toWord(x), Num.toWord(y))); }
  function sub(x:uint, y:uint) -> uint { return uint(subW(Num.toWord(x), Num.toWord(y))); }
  function gt(x:uint, y:uint) -> bool { return Num.gt(Num.toWord(x), Num.toWord(y)); }
}
