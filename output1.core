contract C {
    function Assign_assign$memoryRefLaJ$uint (l : memoryRef{word}, y : uint{word}) -> unit {
      MemoryType_store$uint(Typedef_rep$memoryRefLaJ$uint(l), y)
    }
    function Assign_assign$memoryRefLaJ$word (l : memoryRef{word}, y : word) -> unit {
      MemoryType_store$word(Typedef_rep$memoryRefLaJ$word(l), y)
    }
    function Assign_assign$refLaJ$memoryLwordJ (l : ref{memory{word}}, r : memory{word}) -> unit {
      return ()
    }
    function Assign_assign$refLaJ$word (l : ref{word}, r : word) -> unit {
      return ()
    }
    function LValueMemberAccess_memberAccess$MemberAccessProxyLmemoryLaJ_bJ$S_x_sel_word (x : MemberAccessProxy{(memory{word} * x_sel{unit})}) -> memoryRef{word} {
      let ptr : word
      ptr := Typedef_rep$memoryLaJ$S(memberAccessD1$memoryLSJ_x_sel(x))
      let size : word
      size := MemorySize_size$unit(())
      assembly {
        ptr := add(ptr, size)
      }
      return Typedef_abs$word(ptr)
    }
    function LValueMemberAccess_memberAccess$MemberAccessProxyLmemoryLaJ_bJ$S_y_sel_uint (x : MemberAccessProxy{(memory{word} * y_sel{unit})}) -> memoryRef{word} {
      let ptr : word
      ptr := Typedef_rep$memoryLaJ$S(memberAccessD1$memoryLSJ_y_sel(x))
      let size : word
      size := MemorySize_size$unit(())
      assembly {
        ptr := add(ptr, size)
      }
      return Typedef_abs$word(ptr)
    }
    function LValueMemberAccess_memberAccess$MemberAccessProxyLmemoryLaJ_bJ$S_z_sel_word (x : MemberAccessProxy{(memory{word} * z_sel{unit})}) -> memoryRef{word} {
      let ptr : word
      ptr := Typedef_rep$memoryLaJ$S(memberAccessD1$memoryLSJ_z_sel(x))
      let size : word
      size := MemorySize_size$unit(())
      assembly {
        ptr := add(ptr, size)
      }
      return Typedef_abs$word(ptr)
    }
    function MemorySize_size$unit (x : Proxy{unit}) -> word {
      return 0
    }
    function MemoryType_load$word (ptr : word) -> word {
      let r : word
      assembly {
        r := mload(ptr)
      }
      return r
    }
    function MemoryType_store$uint (ptr : word, value : uint{word}) -> unit {
      return MemoryType_store$word(ptr, Typedef_rep$uint(value))
    }
    function MemoryType_store$word (ptr : word, value : word) -> unit {
      assembly {
        mstore(ptr, value)
      }
    }
    function RValueMemberAccess_memberAccess$MemberAccessProxyLmemoryLaJ_bJ$S_x_sel_word (x : MemberAccessProxy{(memory{word} * x_sel{unit})}) -> word {
      let ptr : word
      ptr := Typedef_rep$memoryLaJ$S(memberAccessD1$memoryLSJ_x_sel(x))
      let size : word
      size := MemorySize_size$unit(())
      assembly {
        ptr := add(ptr, size)
      }
      return MemoryType_load$word(Typedef_abs$word(ptr))
    }
    function Typedef_abs$memoryLaJ$S (x : word) -> memory{word} {
      return x
    }
    function Typedef_abs$word (x : word) -> word {
      return x
    }
    function Typedef_rep$memoryLaJ$S (x : memory{word}) -> word {
      let var_2 : word
      var_2 := x
      return var_2
    }
    function Typedef_rep$memoryRefLaJ$uint (x : memoryRef{word}) -> word {
      let var_2 : word
      var_2 := x
      return var_2
    }
    function Typedef_rep$memoryRefLaJ$word (x : memoryRef{word}) -> word {
      let var_2 : word
      var_2 := x
      return var_2
    }
    function Typedef_rep$uint (x : uint{word}) -> word {
      let var_2 : word
      var_2 := x
      return var_2
    }
    function f () -> unit {
      let x : memory{word}
      let y : memory{word}
      Assign_assign$refLaJ$memoryLwordJ(x, y)
    }
    function g () -> unit {
      let s : memory{word}
      s := Typedef_abs$memoryLaJ$S(128)
      let y : word
      y := 42
      let z : uint{word}
      z := 42
      Assign_assign$memoryRefLaJ$word(LValueMemberAccess_memberAccess$MemberAccessProxyLmemoryLaJ_bJ$S_x_sel_word((s, ())), y)
      Assign_assign$memoryRefLaJ$uint(LValueMemberAccess_memberAccess$MemberAccessProxyLmemoryLaJ_bJ$S_y_sel_uint((s, ())), z)
      Assign_assign$memoryRefLaJ$word(LValueMemberAccess_memberAccess$MemberAccessProxyLmemoryLaJ_bJ$S_z_sel_word((s, ())), y)
      Assign_assign$refLaJ$word(y, RValueMemberAccess_memberAccess$MemberAccessProxyLmemoryLaJ_bJ$S_x_sel_word((s, ())))
      Assign_assign$memoryRefLaJ$word(LValueMemberAccess_memberAccess$MemberAccessProxyLmemoryLaJ_bJ$S_z_sel_word((s, ())), RValueMemberAccess_memberAccess$MemberAccessProxyLmemoryLaJ_bJ$S_x_sel_word((s, ())))
    }
    function main () -> unit {
      f()
      g()
    }
    function memberAccessD1$memoryLSJ_x_sel (x : MemberAccessProxy{(memory{word} * x_sel{unit})}) -> memory{word} {
      let var_3 : memory{word}
      var_3 := fst(x)
      let var_5 : x_sel{unit}
      var_5 := snd(x)
      return var_3
    }
    function memberAccessD1$memoryLSJ_y_sel (x : MemberAccessProxy{(memory{word} * y_sel{unit})}) -> memory{word} {
      let var_3 : memory{word}
      var_3 := fst(x)
      let var_5 : y_sel{unit}
      var_5 := snd(x)
      return var_3
    }
    function memberAccessD1$memoryLSJ_z_sel (x : MemberAccessProxy{(memory{word} * z_sel{unit})}) -> memory{word} {
      let var_3 : memory{word}
      var_3 := fst(x)
      let var_5 : z_sel{unit}
      var_5 := snd(x)
      return var_3
    }
}