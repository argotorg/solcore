
@article{Faxen2002,
author = {Fax\'{e}n, Karl-Filip},
title = {A static semantics for Haskell},
year = {2002},
issue_date = {July 2002},
publisher = {Cambridge University Press},
address = {USA},
volume = {12},
number = {5},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796802004380},
doi = {10.1017/S0956796802004380},
abstract = {This paper gives a static semantics for Haskell 98, a non-strict purely functional programming language. The semantics formally specifies nearly all the details of the Haskell 98 type system, including the resolution of overloading, kind inference (including defaulting) and polymorphic recursion, the only major omission being a proper treatment of ambiguous overloading and its resolution. Overloading is translated into explicit dictionary passing, as in all current implementations of Haskell. The target language of this translation is a variant of the Girard–Reynolds polymorphic lambda calculus featuring higher order polymorphism and explicit type abstraction and application in the term language. Translated programs can thus still be type checked, although the implicit version of this system is impredicative. A surprising result of this formalization effort is that the monomorphism restriction, when rendered in a system of inference rules, compromises the principal type property.},
journal = {J. Funct. Program.},
month = jul,
pages = {295–357},
numpages = {63}
}

@article{PeytonJones2007,
author = {Peyton Jones, Simon and Vytiniotis, Dimitrios and Weirich, Stephanie and Shields, Mark},
title = {Practical type inference for arbitrary-rank types},
year = {2007},
issue_date = {January 2007},
publisher = {Cambridge University Press},
address = {USA},
volume = {17},
number = {1},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796806006034},
doi = {10.1017/S0956796806006034},
abstract = {Haskell's popularity has driven the need for ever more expressive type system features, most of which threaten the decidability and practicality of Damas-Milner type inference. One such feature is the ability to write functions with higher-rank types – that is, functions that take polymorphic functions as their arguments. Complete type inference is known to be undecidable for higher-rank (impredicative) type systems, but in practice programmers are more than willing to add type annotations to guide the type inference engine, and to document their code. However, the choice of just what annotations are required, and what changes are required in the type system and its inference algorithm, has been an ongoing topic of research. We take as our starting point a $lambda$-calculus proposed by Odersky and L\"{a}ufer. Their system supports arbitrary-rank polymorphism through the exploitation of type annotations on $lambda$-bound arguments and arbitrary sub-terms. Though elegant, and more convenient than some other proposals, Odersky and L\"{a}ufer's system requires many annotations. We show how to use local type inference (invented by Pierce and Turner) to greatly reduce the annotation burden, to the point where higher-rank types become eminently usable. Higher-rank types have a very modest impact on type inference. We substantiate this claim in a very concrete way, by presenting a complete type-inference engine, written in Haskell, for a traditional Damas-Milner type system, and then showing how to extend it for higher-rank types. We write the type-inference engine using a monadic framework: it turns out to be a particularly compelling example of monads in action. The paper is long, but is strongly tutorial in style. Although we use Haskell as our example source language, and our implementation language, much of our work is directly applicable to any ML-like functional language.},
journal = {J. Funct. Program.},
month = jan,
pages = {1–82},
numpages = {82}
}
@book{Jones1995,
author = {Jones, Mark P.},
title = {Qualified types: theory and practice},
year = {1995},
isbn = {0521472539},
publisher = {Cambridge University Press},
address = {USA}
}
 @inproceedings{Jones2000,
author = {Jones, Mark P.},
title = {Type Classes with Functional Dependencies},
year = {2000},
isbn = {3540672621},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Type classes in Haskell allow programmers to define functions that can be used on a set of different types, with a potentially different implementation in each case. For example, type classes are used to support equality and numeric types, and for monadic programming. A commonly requested extension to support 'multiple parameters' allows a more general interpretation of classes as relations on types, and has many potentially useful applications. Unfortunately, many of these examples do not work well in practice, leading to ambiguities and inaccuracies in inferred types and delaying the detection of type errors.This paper illustrates the kind of problems that can occur with multiple parameter type classes, and explains how they can be resolved by allowing programmers to specify explicit dependencies between the parameters. A particular novelty of this paper is the application of ideas from the theory of relational databases to the design of type systems.},
booktitle = {Proceedings of the 9th European Symposium on Programming Languages and Systems},
pages = {230–244},
numpages = {15},
series = {ESOP '00}
}

@inproceedings{Chakravarty2005,
author = {Chakravarty, Manuel M. T. and Keller, Gabriele and Jones, Simon Peyton and Marlow, Simon},
title = {Associated types with class},
year = {2005},
isbn = {158113830X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1040305.1040306},
doi = {10.1145/1040305.1040306},
abstract = {Haskell's type classes allow ad-hoc overloading, or type-indexing, of functions. A natural generalisation is to allow type-indexing of data types as well. It turns out that this idea directly supports a powerful form of abstraction called associated types, which are available in C++ using traits classes. Associated types are useful in many applications, especially for self-optimising libraries that adapt their data representations and algorithms in a type-directed manner.In this paper, we introduce and motivate associated types as a rather natural generalisation of Haskell's existing type classes. Formally, we present a type system that includes a type-directed translation into an explicitly typed target language akin to System F; the existence of this translation ensures that the addition of associated data types to an existing Haskell compiler only requires changes to the front end.},
booktitle = {Proceedings of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {1–13},
numpages = {13},
keywords = {type-indexed types, type-directed translation, type classes, self-optimising libraries, associated types},
location = {Long Beach, California, USA},
series = {POPL '05}
}

@article{10.1145/1047659.1040306,
author = {Chakravarty, Manuel M. T. and Keller, Gabriele and Jones, Simon Peyton and Marlow, Simon},
title = {Associated types with class},
year = {2005},
issue_date = {January 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/1047659.1040306},
doi = {10.1145/1047659.1040306},
abstract = {Haskell's type classes allow ad-hoc overloading, or type-indexing, of functions. A natural generalisation is to allow type-indexing of data types as well. It turns out that this idea directly supports a powerful form of abstraction called associated types, which are available in C++ using traits classes. Associated types are useful in many applications, especially for self-optimising libraries that adapt their data representations and algorithms in a type-directed manner.In this paper, we introduce and motivate associated types as a rather natural generalisation of Haskell's existing type classes. Formally, we present a type system that includes a type-directed translation into an explicitly typed target language akin to System F; the existence of this translation ensures that the addition of associated data types to an existing Haskell compiler only requires changes to the front end.},
journal = {SIGPLAN Not.},
month = jan,
pages = {1–13},
numpages = {13},
keywords = {type-indexed types, type-directed translation, type classes, self-optimising libraries, associated types}
}


